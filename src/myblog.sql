/*
SQLyog Ultimate v11.25 (64 bit)
MySQL - 5.7.12-log : Database - myblog
*********************************************************************
*/


/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`myblog` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `myblog`;

/*Table structure for table `blog` */

DROP TABLE IF EXISTS `blog`;

CREATE TABLE `blog` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(100) DEFAULT NULL COMMENT '博客标题',
  `release_date` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '发布时间',
  `content` text COMMENT '博客内容',
  `review` int(11) DEFAULT '0' COMMENT '评论条数',
  `keyword` varchar(50) DEFAULT NULL COMMENT '关键词',
  `summary` text COMMENT '摘要',
  `reading` int(11) DEFAULT '0' COMMENT '阅读次数',
  `type_id` int(11) DEFAULT '1' COMMENT '博客类型',
  `image` varchar(100) DEFAULT NULL COMMENT '图片',
  PRIMARY KEY (`id`),
  KEY `type_id` (`type_id`),
  CONSTRAINT `blog_ibfk_1` FOREIGN KEY (`type_id`) REFERENCES `blog_type` (`type_id`)
) ENGINE=InnoDB AUTO_INCREMENT=129 DEFAULT CHARSET=utf8;

/*Data for the table `blog` */

insert  into `blog`(`id`,`title`,`release_date`,`content`,`review`,`keyword`,`summary`,`reading`,`type_id`,`image`) values (64,'Spring MVC 文件上传','2016-10-21 11:46:16','<p><span style=\"font-size: 14px;\">1. Web文件上传的前提是，form表单的enctype属性值必须为multipart/form-data</span></p><p><span style=\"font-size: 14px;\">2. 配置文件上传的解析器org.springframework.web.multipart.commons.CommonsMultipartResolver</span></p><p><span style=\"font-size: 14px;\">3. 在Controller的处理方法中使用MultipartFile接口作为参数接收。</span></p><p><span style=\"font-size: 14px;\">如：</span></p><pre class=\"brush:java;toolbar:false\">public&nbsp;void&nbsp;fileUpload(@RequestParam(value=&quot;file&quot;,required=false)MultipartFile&nbsp;file){\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;//文件上传代码\r\n}</pre>',0,'文件上传','1. Web文件上传的前提是，form表单的enctype属性值必须为multipart/form-data2. 配置文件上传的解析器org.springframework.web.multipart.commons.CommonsMultipartResolver3. 在Controller的处理方法中使用MultipartFile接口作为参数接收。如：public void fileUpload(@RequestParam(value=\"file\",required=false)MultipartFile file){    //文件上传代码}',15,13,'20161122/1479824883142.jpg'),(65,'Spring MVC中 @RequestMapping注解中的${}占位符','2016-10-21 15:21:09','<p><span style=\"font-size: 14px;\">Spring MVC中@RequestMapping注解中的pattern同样支持${…} 占位符。使用步骤如下：</span></p><p><span style=\"font-size: 14px;\">1. 创建属性文件，如requestMapping.properties文件，文件内容大致如下：（以键值对的方式配置）<br/></span></p><pre class=\"brush:xml;toolbar:false;\">user.list=/user/list</pre><p><span style=\"font-size: 14px;\"></span><span style=\"font-size: 14px;\">2. 在SpringMVC的配置文件中（如springmvc.xml）配置如下信息：</span></p><pre class=\"brush:xml;toolbar:false\">&lt;bean&nbsp;class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;location&quot;&nbsp;value=&quot;classpath:requestMapping.properties&quot;/&gt;\r\n&lt;/bean&gt;</pre><p><span style=\"font-size: 14px;\"></span><span style=\"font-size: 14px;\">3. 最后在@RequestMapping注解中使用，如下：</span></p><pre class=\"brush:java;toolbar:false\">@RequestMapping(&quot;${user.list}&quot;)</pre><p><span style=\"font-size: 14px;\"></span><br/></p>',0,'SpringMVC RequstMapping 注解','Spring MVC中@RequestMapping注解中的pattern同样支持${…} 占位符。使用步骤如下：1. 创建属性文件，如requestMapping.properties文件，文件内容大致如下：（以键值对的方式配置）user.list=/user/list2. 在SpringMVC的配置文件中（如springmvc.xml）配置如下信息：<bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\">   <property name=\"location\" value=\"c',43,13,'20161122/1479824863718.jpg'),(66,'Spring IOC 整合Servlet','2016-10-22 19:58:37','<p><span style=\"font-size: 14px;\"><span style=\"font-size: 16px; font-style: italic; font-weight: bold; line-height: 18px;\"></span>由于Servlet也是一个简单的类，只不过该类需要直接或间接实现javax.servlet.Servlet接口。</span></p><p><span style=\"font-size: 14px;\">所以可以在Spring的IOC容器中实例化它，并且可以配置其与业务逻辑层的依赖。</span></p><p><span style=\"font-size: 14px;\">但是如果使用SpringIOC注入方式来实例化Servlet，Servlet有关Web容器的上下文就不能得到。</span></p><p><span style=\"font-size: 14px;\">既要能在SpringIOC中实例化Servlet，又要能够得到Web容器的上下文。做法是：为自定义的Servlet编写一个前端Servlet，用该Servlet来从SpringIOC容器中获得目标Servlet，同时将Web容器的上下文设置到自定义Servlet。</span></p><p><span style=\"font-size: 14px;\">1. 编写前端Servlet，用于从Spring IOC容器中得到实例化的Servlet<br/></span></p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.springmvc.controller;\r\n\r\nimport&nbsp;java.io.IOException;\r\n\r\nimport&nbsp;javax.servlet.GenericServlet;\r\nimport&nbsp;javax.servlet.Servlet;\r\nimport&nbsp;javax.servlet.ServletConfig;\r\nimport&nbsp;javax.servlet.ServletException;\r\nimport&nbsp;javax.servlet.ServletRequest;\r\nimport&nbsp;javax.servlet.ServletResponse;\r\n\r\nimport&nbsp;org.springframework.context.ApplicationContext;\r\nimport&nbsp;org.springframework.web.context.support.WebApplicationContextUtils;\r\n\r\npublic&nbsp;class&nbsp;ProxySpringServlet&nbsp;extends&nbsp;GenericServlet&nbsp;{\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;long&nbsp;serialVersionUID&nbsp;=&nbsp;1L;\r\n&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;ApplicationContext&nbsp;applicationContext;&nbsp;//Spring&nbsp;IOC&nbsp;容器\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Servlet&nbsp;requestServlet;&nbsp;//用户请求的Servlet\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;requestServletName;&nbsp;//用户请求的Servlet名称\r\n&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;service(ServletRequest&nbsp;arg0,&nbsp;ServletResponse&nbsp;arg1)&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;ServletException,&nbsp;IOException&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取用户当前请求的Servlet\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestServletName&nbsp;=&nbsp;getServletName();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestServlet&nbsp;=&nbsp;applicationContext.getBean(requestServletName,Servlet.class);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//调用用户当前请求的Servlet的service方法\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;requestServlet.service(arg0,&nbsp;arg1);\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;init(ServletConfig&nbsp;config)&nbsp;throws&nbsp;ServletException&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.init(config);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获得Spring&nbsp;IOC&nbsp;的上下文对象\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;applicationContext&nbsp;=&nbsp;WebApplicationContextUtils\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.getRequiredWebApplicationContext(getServletContext());\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n\r\n}</pre><p>2. 在web.xml中初始化Spring IOC</p><p><span style=\"font-size: 14px;\">&nbsp; 1. Spring Web中有一个ContextLoaderListener，可以通过在web.xml中配置它来初始化Spring IOC容器</span></p><p><span style=\"font-size: 14px;\">&nbsp; 2. 在初始化时，需要给Listener提供Spring IOC配置文件</span></p><p><span style=\"font-size: 14px;\">&nbsp; 3. 在web.xml中添加容器参数context-param，参数的值就是Spring IOC的配置文件路径，如下：</span></p><pre class=\"brush:xml;toolbar:false\">&lt;context-param&gt;\r\n&nbsp;&nbsp;&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\r\n&nbsp;&nbsp;&lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;\r\n&lt;/context-param&gt;\r\n&lt;listener&gt;\r\n&nbsp;&nbsp;&nbsp;&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;\r\n&lt;/listener&gt;</pre><p><span style=\"font-size: 14px;\"></span>3. 创建LoginServlet，并继承于前端Servlet（ProxySpringServlet），如下：</p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.springmvc.controller;\r\n\r\nimport&nbsp;java.io.IOException;\r\n\r\nimport&nbsp;javax.servlet.ServletConfig;\r\nimport&nbsp;javax.servlet.ServletException;\r\nimport&nbsp;javax.servlet.ServletRequest;\r\nimport&nbsp;javax.servlet.ServletResponse;\r\n\r\npublic&nbsp;class&nbsp;LoginServlet&nbsp;extends&nbsp;ProxySpringServlet{\r\n&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;long&nbsp;serialVersionUID&nbsp;=&nbsp;1L;\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;service(ServletRequest&nbsp;arg0,&nbsp;ServletResponse&nbsp;arg1)&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;ServletException,&nbsp;IOException&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Login...&quot;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.service(arg0,&nbsp;arg1);\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;@Override\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;init(ServletConfig&nbsp;config)&nbsp;throws&nbsp;ServletException&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.init(config);\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</pre><p>4. 在web.xml中配置LoginServlet和ProxySpringServlet，如下：</p><pre class=\"brush:xml;toolbar:false\">&nbsp;&nbsp;&nbsp;&nbsp;&lt;servlet&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;servlet-name&gt;loginServlet&lt;/servlet-name&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;servlet-class&gt;com.springmvc.controller.LoginServlet&lt;/servlet-class&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/servlet&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;servlet&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;servlet-name&gt;login&lt;/servlet-name&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;servlet-class&gt;com.springmvc.controller.ProxySpringServlet&lt;/servlet-class&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/servlet&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;servlet-mapping&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;servlet-name&gt;loginServlet&lt;/servlet-name&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;url-pattern&gt;/login&lt;/url-pattern&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/servlet-mapping&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;servlet-mapping&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;servlet-name&gt;login&lt;/servlet-name&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;url-pattern&gt;/proxy&lt;/url-pattern&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/servlet-mapping&gt;</pre><p>5. 在Spring的配置文件中加入LoginServlet的bean配置，如下：</p><pre class=\"brush:xml;toolbar:false\">&lt;bean&nbsp;id=&quot;login&quot;&nbsp;class=&quot;com.springmvc.controller.LoginServlet&quot;&gt;&lt;/bean&gt;</pre><p><br/></p>',1,'Spring Servlet','由于Servlet也是一个简单的类，只不过该类需要直接或间接实现javax.servlet.Servlet接口。所以可以在Spring的IOC容器中实例化它，并且可以配置其与业务逻辑层的依赖。但是如果使用SpringIOC注入方式来实例化Servlet，Servlet有关Web容器的上下文就不能得到。既要能在SpringIOC中实例化Servlet，又要能够得到Web容器的上下文。做法是：为自定义...',45,24,'20161123/1479914334796.jpg'),(69,'Spring AOP 基础','2016-10-24 15:01:39','<p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>AOP</strong></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented \r\nProgramming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross\r\n cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">AOP技术恰恰相反，它利用一种称为&quot;横切&quot;的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为&quot;Aspect&quot;，即切面。所谓&quot;切面&quot;，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">使用&quot;横切&quot;技术，AOP把软件系统分为两个部分：<strong>核心关注点</strong>和<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>横切关注点</strong></span>。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">&nbsp;</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>AOP核心概念</strong></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">1、横切关注点</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">2、切面（aspect）</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">类是对物体特征的抽象，切面就是对横切关注点的抽象</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">3、连接点（joinpoint）</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">4、切入点（pointcut）</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">对连接点进行拦截的定义</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">5、通知（advice）</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">6、目标对象</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">代理的目标对象</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">7、织入（weave）</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">将切面应用到目标对象并导致代理对象创建的过程</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">8、引入（introduction）</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">在不修改代码的前提下，引入可以在<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>运行期</strong></span>为类动态地添加一些方法或字段</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">&nbsp;</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>Spring对AOP的支持</strong></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理</strong></span>。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。Spring创建代理的规则为：</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">1、<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>默认使用Java动态代理来创建AOP代理</strong></span>，这样就可以为任何接口实例创建代理了</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">2、<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理</strong></span>，也可强制使用CGLIB</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">AOP编程其实是很简单的事情，纵观AOP编程，程序员只需要参与三个部分：</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">1、定义普通业务组件</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">2、定义切入点，一个切入点可能横切多个业务组件</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">3、定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">所以进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理，即：<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>代理对象的方法=增强处理+被代理对象</strong></span>的方法。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><br/></span></p><p><strong><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">Spring提供了4种实现AOP的方式</span></strong><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">：</span></p><ol style=\"list-style-type: decimal;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">经典的基于代理的AOP<br/></span></p></li><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">@AspectJ注解驱动的切面<br/></span></p></li><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">纯POJO切面<br/></span></p></li><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">注入式AspectJ切面</span></p></li></ol><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><br/></span></p><p><strong><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">Spring支持以下五种类型的通知：</span></strong><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><br/></span></p><pre class=\"brush:plain;toolbar:false\">Before(前置通知)&nbsp;&nbsp;org.apringframework.aop.MethodBeforeAdvice\r\nAfter-Returning(返回通知)&nbsp;org.springframework.aop.AfterReturningAdvice\r\nAfter-Throwing(异常通知)&nbsp;org.springframework.aop.ThrowsAdvice\r\nArround(环绕通知)&nbsp;org.aopaliance.intercept.MethodInterceptor\r\nIntroduction(引入通知)&nbsp;org.springframework.aop.IntroductionInterceptor</pre>',0,'Spring AOP 基础','AOPAOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented \r\nProgramming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应...',9,14,'20161122/1479824722552.jpg'),(70,'Spring AOP 的注解方式实现','2016-10-24 15:03:41','<p><span style=\"font-size: 14px;\">1) 首先加入Spring需要的基础jar包<br/><br/>commons-logging-1.2.jar<br/>spring-beans-4.3.2.RELEASE.jar<br/>spring-context-4.3.2.RELEASE.jar<br/>spring-core-4.3.2.RELEASE.jar<br/>spring-expression-4.3.2.RELEASE.jar<br/><br/>2) 再加入Spring AOP 需要的jar包<br/><br/>aspectjrt-1.8.3.jar<br/>aspectjweaver-1.8.9.jar<br/>spring-aop-4.3.2.RELEASE.jar<br/>spring-aspects-4.3.2.RELEASE.jar<br/><br/>3) 在配置文件中加入aop的命名空间<br/><br/>4) 基于注解的方式<br/>① 在配置文件中加入如下配置：<br/></span></p><pre class=\"brush:xml;toolbar:false\">&lt;!--&nbsp;指定Spring&nbsp;自动扫描的包&nbsp;--&gt;\r\n&lt;context:component-scan&nbsp;base-package=&quot;com.spring.aop&quot;/&gt;\r\n&lt;!--&nbsp;启用aspect注解&nbsp;--&gt;\r\n&lt;aop:aspectj-autoproxy/&gt;</pre><p><span style=\"font-size: 14px;\">② 把横切关注点的代码抽象到切面的类中<br/>i.&nbsp; 切面首先是一个IOC 中的bean，即加入 @Component 注解<br/>ii. 切面还需要加入 @Aspect 注解<br/><br/>③ 在类中声明各种类型的通知<br/>i.&nbsp; 声明一个方法<br/>ii. 在方法前加入 @Before 注解，表示该方法是一个前置通知，如@Before(&quot;execution(* com.spring.aop.*.*(..))&quot;)表示通知<br/>&nbsp;&nbsp; &nbsp;com.spring.aop包下的所有类的所有方法。<br/></span></p><p><span style=\"font-size: 14px;\">④ 可以在通知方法中声明一个类型为 JoinPoint 的参数，然后就能访问连接的细节，如方法名称和参数值<br/></span></p>',0,'Spring AOP 注解','1) 首先加入Spring需要的基础jar包commons-logging-1.2.jarspring-beans-4.3.2.RELEASE.jarspring-context-4.3.2.RELEASE.jarspring-core-4.3.2.RELEASE.jarspring-expression-4.3.2.RELEASE.jar2) 再加入Spring AOP 需要的jar包aspec...',48,14,'20161127/1480177889747.jpg'),(71,'Spring AOP 重用切点表达式','2016-10-25 11:12:07','<p><span style=\"font-size: 14px;\">在Spring 的 AOP中，支持切点表达式的重用，简单用法如下（注解方式）：</span></p><p><span style=\"font-size: 14px;\">1. 首先声明一个类为一个切面</span>，使用@Aspect注解</p><p><span style=\"font-size: 14px;\">2. 然后声明一个方法为一个切点，通常声明为private，返回值类型为void。在方法上加上@PointCut注解，如</span></p><pre class=\"brush:java;toolbar:false\">@PointCut(&quot;execution(*&nbsp;com.spring.aop.*.*(..))&quot;)\r\nprivate&nbsp;void&nbsp;anyMethod(){}</pre><p><span style=\"font-size: 14px;\"></span><span style=\"font-size: 14px;\">3. 在需要使用切点表达式的方法上使用@Before、@After等注解声明为通知，并在其中引用切点方法的签名。如下：</span></p><pre class=\"brush:java;toolbar:false\">@Before(&quot;anyMethod()&quot;)\r\npublic&nbsp;void&nbsp;doBefore(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;Before&nbsp;method...&quot;);\r\n}</pre><p><span style=\"font-size: 14px;\"></span><br/></p><p><span style=\"font-size: 14px;\"></span><br/></p>',0,'Spring AOP 注解 切点表达式','在Spring 的 AOP中，支持切点表达式的重用，简单用法如下（注解方式）：1. 首先声明一个类为一个切面，使用@Aspect注解2. 然后声明一个方法为一个切点，通常声明为private，返回值类型为void。在方法上加上@PointCut注解，如@PointCut(\"execution(* com.spring.aop.*.*(..))\")private void anyMethod(){}',11,14,'20161122/1479824650687.jpg'),(73,'Java基础面试题（易错题）','2016-10-27 11:27:30','<p><span style=\"font-size: 14px;\"><strong>1. switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？</strong><br/>答：在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java \r\n5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java \r\n7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</span></p><p><span style=\"font-size: 14px;\"><strong>2. 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</strong><br/>答：是值传递。Java语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的。C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。在C#中可以编写如下所示的代码，但是在Java中却做不到。</span></p><pre class=\"brush:c#;toolbar:false\">using&nbsp;System;\r\n&nbsp;\r\nnamespace&nbsp;CS01&nbsp;{\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;class&nbsp;Program&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;swap(ref&nbsp;int&nbsp;x,&nbsp;ref&nbsp;int&nbsp;y)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;temp&nbsp;=&nbsp;x;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;=&nbsp;y;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;temp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;Main&nbsp;(string[]&nbsp;args)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;a&nbsp;=&nbsp;5,&nbsp;b&nbsp;=&nbsp;10;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap&nbsp;(ref&nbsp;a,&nbsp;ref&nbsp;b);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;a&nbsp;=&nbsp;10,&nbsp;b&nbsp;=&nbsp;5;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine&nbsp;(&quot;a&nbsp;=&nbsp;{0},&nbsp;b&nbsp;=&nbsp;{1}&quot;,&nbsp;a,&nbsp;b);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</pre><p><span style=\"font-size: 14px;\">说明：Java中没有传引用实在是非常的不方便，这一点在Java \r\n8中仍然没有得到改进，正是如此在Java编写的代码中才会出现大量的Wrapper类（将需要通过方法调用修改的引用置于一个Wrapper类中，再将Wrapper对象传入方法），这样的做法只会让代码变得臃肿，尤其是让从C和C++转型为Java程序员的开发者无法容忍。</span></p><p><span style=\"font-size: 14px;\"><strong>3. </strong><strong>try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?</strong><br/>答：会执行，在方法返回调用者前执行。<strong><br/></strong></span></p><p><span style=\"font-size: 14px;\"><strong>注意：</strong>在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值，然后如果在finally中修改了返回值，就会返回修改后的值。显然，在finally中返回或者修改返回值会对程序造成很大的困扰，C#中直接用编译错误的方式来阻止程序员干这种龌龊的事情，Java中也可以通过提升编译器的语法检查级别来产生警告或错误，Eclipse中可以在如图所示的地方进行设置，强烈建议将此项设置为编译错误。</span></p><p><span style=\"font-size: 14px;\"><strong>4. 阐述final、finally、finalize的区别。</strong><br/>答：<br/>- \r\nfinal：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final的方法也同样只能使用，不能在子类中被重写。<br/>- finally：通常放在try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。<br/>- \r\nfinalize：Object类中定义的方法，Java中允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作。<br/></span></p><p><span style=\"font-size: 14px;\"><span style=\"font-size: 14px;\"><strong>5. try...catch...finally语句块中，catch中有return语句<span style=\"font-size: 14px;\"><strong>，那么紧跟在这个catch后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?</strong></span></strong></span></span></p><p><span style=\"font-size: 14px;\"><span style=\"font-size: 14px;\"><span style=\"font-size: 14px;\"></span><span style=\"font-size: 14px;\">答：会执行，在return语句执行过程中执行。如下代码：</span></span></span></p><pre class=\"brush:java;toolbar:false\">public&nbsp;class&nbsp;Test{\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(fun());//执行结果：exception&nbsp;finally&nbsp;-1\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;int&nbsp;fun(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;5;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;result&nbsp;/&nbsp;0;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;exception&quot;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;-1;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}finally&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;10;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;finally&quot;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</pre><p><strong><span style=\"font-size: 14px;\">6. Java中对象向上转型后的属性及方法覆盖情况？</span></strong></p><p><span style=\"font-size: 14px;\">答：属性不会覆盖，而方法会覆盖。如下代码：</span></p><pre class=\"brush:java;toolbar:false\">class&nbsp;SuperClass{\r\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;10;\r\n&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;void&nbsp;show()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;super...&quot;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}\r\n\r\nclass&nbsp;SubClass&nbsp;extends&nbsp;SuperClass{\r\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;30;\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;show()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;sub...&quot;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}\r\n\r\npublic&nbsp;class&nbsp;Test{\r\n&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SuperClass&nbsp;superClass&nbsp;=&nbsp;new&nbsp;SubClass();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;superClass.show();//执行结果：sub...\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(superClass.i);//执行结果：10\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</pre><p><strong><span style=\"font-size: 14px;\">7. 区分Java中的形式参数和实际参数。</span></strong><span style=\"font-size: 14px;\">代码如下：</span></p><pre class=\"brush:java;toolbar:false\">public&nbsp;class&nbsp;Test{\r\n&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;change(String&nbsp;s){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;=&nbsp;&quot;123&quot;;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;str&nbsp;=&nbsp;&quot;hello&quot;;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;change(str);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(str);//执行结果：hello\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</pre><p><span style=\"font-size: 14px;\">上面的代码中，两个String类型的对象str和s一个是实际参数，一个是形式参数。change方法中仅仅改变了形式参数的值，而没有改变实际的str参数值。</span><br/></p>',0,'Java基础','1. switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？答：在Java 5以前，switch(expr)中，expr只能是byte、short、char、int。从Java \r\n5开始，Java中引入了枚举类型，expr也可以是enum类型，从Java \r\n7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。...',12,10,'20161123/1479868847718.jpg'),(74,'Hibernate配置一对多的关系','2016-11-03 11:01:02','<p><span style=\"font-size: 14px;\">建立一对多关系关系的表的原则是将一的一方的主键加入到多的一方的表作为外键。</span></p><p><span style=\"font-size: 14px;\">需要在“一”的一方类中加入一个set集合，里面存放“多”的一方的对象。</span></p><p><span style=\"font-size: 14px;\">而在“多”的一方的类中需要加入一个“一”方的对象。学生和成绩的关系就是典型的一对多，如下例子所示：</span></p><p><span style=\"font-size: 14px;\">学生Student类：<br/></span></p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.xjc.bean;\r\n\r\nimport&nbsp;java.util.Date;\r\nimport&nbsp;java.util.Set;\r\n\r\npublic&nbsp;class&nbsp;Student&nbsp;{\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;id;\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;gender;\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Date&nbsp;birthDate;\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Set&lt;Score&gt;&nbsp;scores&nbsp;=&nbsp;new&nbsp;HashSet&lt;&gt;();//用一个集合保存成绩信息\r\n&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Set&lt;Score&gt;&nbsp;getScores()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;scores;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setScores(Set&lt;Score&gt;&nbsp;scores)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.scores&nbsp;=&nbsp;scores;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;getId()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;id;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setId(int&nbsp;id)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.id&nbsp;=&nbsp;id;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;getName()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;name;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setName(String&nbsp;name)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;getGender()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;gender;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setGender(String&nbsp;gender)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.gender&nbsp;=&nbsp;gender;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Date&nbsp;getBirthDate()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;birthDate;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setBirthDate(Date&nbsp;birthDate)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.birthDate&nbsp;=&nbsp;birthDate;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</pre><p><span style=\"font-size: 14px;\">成绩Score类：</span></p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.xjc.bean;\r\n\r\npublic&nbsp;class&nbsp;Score&nbsp;{\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;id;\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;double&nbsp;score;\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Student&nbsp;student;&nbsp;//表示是哪个学生的成绩\r\n&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;getId()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;id;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setId(int&nbsp;id)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.id&nbsp;=&nbsp;id;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;double&nbsp;getScore()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;score;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setScore(double&nbsp;score)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.score&nbsp;=&nbsp;score;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Student&nbsp;getStudent()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;student;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setStudent(Student&nbsp;student)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.student&nbsp;=&nbsp;student;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</pre><p><span style=\"font-size: 14px;\">在学生的实体类中包含成绩的Set集合，在成绩的实体类中则包含学生的对象。这样就可以表示一对多的关系了。</span><span style=\"font-size: 14px;\"></span><br/></p><p><span style=\"font-size: 14px; color: rgb(192, 0, 0);\">注意</span><span style=\"font-size: 14px; color: rgb(192, 0, 0);\">：</span><span style=\"font-size: 14px;\"> <br/></span></p><ul style=\"list-style-type: disc;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px;\"><span style=\"font-size: 14px;\">在映射单向一对多的关联时，只需要在&quot;一&quot;方配置。</span></span></p></li><li><p><span style=\"font-size: 14px;\"><span style=\"font-size: 14px;\">在Student类中，成绩集合scores必须被实例化。</span></span></p></li></ul><p><span style=\"font-size: 14px;\">写完实体类后就要配置这两个类和表之间的映射关系了，如下：</span></p><p><span style=\"font-size: 14px;\">1. Student.hbm.xml<br/></span></p><pre class=\"brush:xml;toolbar:false\">&lt;hibernate-mapping&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;表和类之间的映射&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;class&nbsp;name=&quot;com.hibernate.bean.Student&quot;&nbsp;table=&quot;stu&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;主键映射&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;id&nbsp;name=&quot;id&quot;&nbsp;column=&quot;id&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;generator&nbsp;class=&quot;native&quot;&gt;&lt;/generator&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/id&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;属性映射&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;name&quot;&nbsp;column=&quot;name&quot;&nbsp;type=&quot;java.lang.String&quot;/&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;gender&quot;&nbsp;column=&quot;gender&quot;&nbsp;type=&quot;java.lang.String&quot;/&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;birthDate&quot;&nbsp;column=&quot;birth_date&quot;&nbsp;type=&quot;java.util.Date&quot;/&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;表之间关系映射&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;set&nbsp;name=&quot;scores&quot;&nbsp;cascade=&quot;save-update,delete&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;key&nbsp;column=&quot;stuId&quot;&gt;&lt;/key&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;one-to-many&nbsp;class=&quot;com.hibernate.bean.Score&quot;/&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/set&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/class&gt;\r\n&lt;/hibernate-mapping&gt;</pre><p><span style=\"font-size: 14px;\">2. Score.hbm.xml</span></p><pre class=\"brush:xml;toolbar:false\">&lt;hibernate-mapping&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;表和类之间的映射&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;class&nbsp;name=&quot;com.hibernate.bean.Score&quot;&nbsp;table=&quot;score&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;主键映射&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;id&nbsp;name=&quot;id&quot;&nbsp;column=&quot;id&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;generator&nbsp;class=&quot;native&quot;&gt;&lt;/generator&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/id&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;属性映射&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;score&quot;&nbsp;column=&quot;score&quot;&nbsp;type=&quot;java.lang.String&quot;&nbsp;length=&quot;50&quot;/&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;表之间关系映射&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;many-to-one&nbsp;name=&quot;student&quot;&nbsp;column=&quot;stuId&quot;&gt;&lt;/many-to-one&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/class&gt;\r\n&lt;/hibernate-mapping&gt;</pre><p><span style=\"font-size: 14px;\">这里加了&lt;many-to-one&gt;&lt;/many-to-one&gt;表示Score与Student是多对一的关系，name=&quot;student&quot;表示在Score类里面有一个属性是student对应对象student,column=&quot;stuId&quot;表示\r\n 它们之间是用stuId建立联系的。</span></p><p><br/></p>',0,'Hibernate 一对多','建立一对多关系关系的表的原则是将一的一方的主键加入到多的一方的表作为外键。需要在“一”的一方类中加入一个set集合，里面存放“多”的一方的对象。而在“多”的一方的类中需要加入一个“一”方的对象。学生和成绩的关系就是典型的一对多，如下例子所示：学生Student类：package com.xjc.bean;import java.util.Date;import java.util.Set;publ...',14,15,'20161126/1480099299012.jpg'),(75,'关于树的一些基本概念','2016-11-04 11:24:19','<p><strong><span style=\"font-size: 14px;\">树。</span></strong><strong><span style=\"font-size: 14px;\">树</span></strong><span style=\"font-size: 14px;\">是结点的一个有限集合。这个集合可能是空的（没有结点，被称作<strong>空树</strong>）。但是如果集合不是空的，它就必须遵循下述规则：</span></p><ol style=\"list-style-type: decimal;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px;\">有一个特殊的结点，叫作<strong>根结点</strong>。</span></p></li><li><p><span style=\"font-size: 14px;\">每个结点可以与一个或多个不同的结点相连，这些结点被叫做是它的<strong>孩子</strong>。如果一个结点c是另一个结点p的孩子，那么我们就说“p是c的<strong>双亲</strong>”。</span></p></li><li><p><span style=\"font-size: 14px;\">除根结点外的每个结点有且仅有一个双亲；根结点没有双亲。</span></p></li><li><p><span style=\"font-size: 14px;\">如果从某个结点开始移动到它的双亲（假设它有双亲），然后再移动到那个结点的双亲（<span style=\"font-size: 14px;\">假设它有双亲</span>），继续移动到每个结点的双亲，最后就会到达根结点。</span></p></li></ol><p><strong><span style=\"font-size: 14px;\">二叉树</span></strong><span style=\"font-size: 14px;\">：二叉树中<strong>每个结点</strong><strong>最多</strong><strong>只能有两个孩子</strong>。<br/></span></p><p><span style=\"font-size: 14px;\"><strong>结点的深度</strong>。假设从一个结点n开始向上移动到它的双亲。我们把这叫做“一步”。然后移动到双亲的双亲---这是第二步。最后，你会到达根结点。所走过的步数就叫做<strong>结点n的深度</strong>。根结点的深度是0，根结点的孩子的深度是1。<br/></span></p><p><span style=\"font-size: 14px;\"><strong>树的</strong><strong>深度</strong>。<span style=\"font-size: 14px;\"><strong>树的</strong><strong>深度</strong></span>是它的所有叶子节点的最大的深度。</span></p><p><span style=\"font-size: 14px; color: rgb(192, 0, 0);\">注意</span><span style=\"font-size: 14px;\">：如果一棵树只有一个根结点，那么它的深度就是0（因为根结点的深度是0）。空树没有任何叶子结点，所以我们用-1来表示它的深度。</span></p><p><strong><span style=\"font-size: 14px;\">满二叉树</span></strong><span style=\"font-size: 14px;\">。<span style=\"font-size: 14px;\">在</span><strong><span style=\"font-size: 14px;\">满二叉树</span></strong><span style=\"font-size: 14px;\">中，</span><span style=\"font-size: 14px;\">每个叶子结点的深度都相同，每个非叶子结点都有两个孩子。如图：</span></span></p><p><strong><span style=\"font-size: 14px;\"><span style=\"font-size: 14px;\">完全二叉树</span></span></strong><span style=\"font-size: 14px;\"><span style=\"font-size: 14px;\">。对于完全二叉树，除最深一层之外的每层都包含尽可能多的结点；在最深的一层，所有结点都尽可能的排在左边。</span></span></p><p><span style=\"font-size: 14px; color: rgb(192, 0, 0);\">注意</span><span style=\"font-size: 14px;\">：深度为n的完全二叉树的叶子结点最多为（2<sup>n</sup>），总的结点数最多为（2<sup>n+1</sup>-1）。如图：</span></p>',0,'树','树。树是结点的一个有限集合。这个集合可能是空的（没有结点，被称作空树）。但是如果集合不是空的，它就必须遵循下述规则：有一个特殊的结点，叫作根结点。每个结点可以与一个或多个不同的结点相连，这些结点被叫做是它的孩子。如果一个结点c是另一个结点p的孩子，那么我们就说“p是c的双亲”。除根结点外的每个结点有且仅有一个双亲；根结点没有双亲。如果从某个结点开始移动到它的双亲（假设它有双亲），然后再移动到那个结...',19,16,'20161126/1480099393075.jpg'),(76,'Java中的单例模式','2016-11-08 10:39:53','<p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">单例模式要达到以下几个目的：</span></p><ol style=\"list-style-type: decimal;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">确保某一个类只有一个实例</span></p></li><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">这个类必须自行实例化并向整个系统提供这个实例</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p></li></ol><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">因此，为了达到以上的几个目的，单例模式必须具有以下几个特点：</span></p><ol style=\"list-style-type: decimal;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">单例类的构造方法为私有</span></p></li><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">提供一个自身的静态私有成员变量</span></p></li><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">提供一个共有的静态工厂方法</span></p></li></ol><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">单例模式的实现方式有很多种，它们各自适用的情况也不尽相同。<br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\">饿汉法</span></strong></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">顾名思义，饿汉法就是在第一次引用该类的时候就创建对象实例，而不管实际是否需要创建。代码如下：</span></p><pre class=\"brush:java;toolbar:false\">public&nbsp;class&nbsp;Singleton&nbsp;{&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;Singleton&nbsp;=&nbsp;new&nbsp;Singleton();\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Singleton()&nbsp;{}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;getSignleton(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;singleton;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</pre><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">这样做的好处是编写简单，但是无法做到延迟创建对象。但是我们很多时候都希望对象可以尽可能地延迟加载，从而减小负载，所以就需要下面的懒汉法：</span></p><h3><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\">单线程写法</span></strong></span></h3><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">这种写法是最简单的，由私有构造器和一个公有静态工厂方法构成，在工厂方法中对singleton进行null判断，如果是null就new一个出来，最后返回singleton对象。这种方法可以实现延时加载，但是有一个致命弱点：线程不安全。如果有两条线程同时调用getSingleton()方法，就有很大可能导致重复创建对象。</span></p><pre class=\"brush:java;toolbar:false\">public&nbsp;class&nbsp;Singleton&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;Singleton&nbsp;singleton&nbsp;=&nbsp;null;\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Singleton(){}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;getSingleton()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(singleton&nbsp;==&nbsp;null)&nbsp;singleton&nbsp;=&nbsp;new&nbsp;Singleton();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;singleton;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</pre><h3><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\">考虑线程安全的写法</span></strong></span></h3><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">这种写法考虑了线程安全，将对singleton的null判断以及new的部分使用synchronized进行加锁。同时，对singleton对象使用volatile关键字进行限制，保证其对所有线程的可见性，并且禁止对其进行指令重排序优化。如此即可从语义上保证这种单例模式写法是线程安全的。注意，这里说的是语义上，实际使用中还是存在小坑的，会在后文写到。</span></p><pre class=\"brush:java;toolbar:false\">public&nbsp;class&nbsp;Singleton&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;volatile&nbsp;Singleton&nbsp;singleton&nbsp;=&nbsp;null;\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Singleton(){}\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;getSingleton(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized&nbsp;(Singleton.class){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(singleton&nbsp;==&nbsp;null){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;singleton&nbsp;=&nbsp;new&nbsp;Singleton();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;singleton;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;\r\n}</pre><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p><h3><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\">兼顾线程安全和效率的写法</span></strong></span></h3><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">虽然上面这种写法是可以正确运行的，但是其效率低下，还是无法实际应用。因为每次调用getSingleton()方法，都必须在synchronized这里进行排队，而真正遇到需要new的情况是非常少的。所以，就诞生了第三种写法：</span></p><pre class=\"brush:java;toolbar:false\">public&nbsp;class&nbsp;Singleton&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;volatile&nbsp;Singleton&nbsp;singleton&nbsp;=&nbsp;null;\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Singleton(){}\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;getSingleton(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(singleton&nbsp;==&nbsp;null){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized&nbsp;(Singleton.class){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(singleton&nbsp;==&nbsp;null){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;singleton&nbsp;=&nbsp;new&nbsp;Singleton();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;singleton;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;\r\n}</pre><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">这种写法被称为“双重检查锁”，顾名思义，就是在getSingleton()方法中，进行两次null检查。看似多此一举，但实际上却极大提升了并发度，进而提升了性能。为什么可以提高并发度呢？就像上文说的，在单例中new的情况非常少，绝大多数都是可以并行的读操作。因此在加锁前多进行一次null检查就可以减少绝大多数的加锁操作，执行效率提高的目的也就达到了。</span></p><h3><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\">坑</span></strong></span></h3><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">那么，这种写法是不是绝对安全呢？前面说了，从语义角度来看，并没有什么问题。但是其实还是有坑。说这个坑之前我们要先来看看volatile这个关键字。其实这个关键字有两层语义。第一层语义相信大家都比较熟悉，就是可见性。可见性指的是在一个线程中对该变量的修改会马上由工作内存（Work\r\n Memory）写回主内存（Main \r\nMemory），所以会马上反应在其它线程的读取操作中。顺便一提，工作内存和主内存可以近似理解为实际电脑中的高速缓存和主存，工作内存是线程独享的，主存是线程共享的。volatile的第二层语义是禁止指令重排序优化。大家知道我们写的代码（尤其是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同。这在单线程看起来没什么问题，然而一旦引入多线程，这种乱序就可能导致严重问题。volatile关键字就可以从语义上解决这个问题。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">注意，前面反复提到“从语义上讲是没有问题的”，但是很不幸，禁止指令重排优化这条语义直到jdk1.5以后才能正确工作。此前的JDK中即使将变量声明为volatile也无法完全避免重排序所导致的问题。所以，在jdk1.5版本前，双重检查锁形式的单例模式是无法保证线程安全的。</span></p><h3><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\">静态内部类法</span></strong></span></h3><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">那么，有没有一种延时加载，并且能保证线程安全的简单写法呢？我们可以把Singleton实例放到一个静态内部类中，这样就避免了静态实例在Singleton类加载的时候就创建对象，并且由于静态内部类只会被加载一次，所以这种写法也是线程安全的：</span></p><pre class=\"brush:java;toolbar:false\">public&nbsp;class&nbsp;Singleton&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;class&nbsp;Holder&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;Singleton&nbsp;singleton&nbsp;=&nbsp;new&nbsp;Singleton();\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Singleton(){}\r\n&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;getSingleton(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;Holder.singleton;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</pre><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">但是，上面提到的所有实现方式都有两个共同的缺点：</span></p><ul class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">都需要额外的工作(Serializable、transient、readResolve())来实现序列化，否则每次反序列化一个序列化的对象实例时都会创建一个新的实例。</span></p></li><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">可能会有人使用反射强行调用我们的私有构造器（如果要避免这种情况，可以修改构造器，让它在创建第二个实例的时候抛异常）。</span></p></li></ul><h3><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\">枚举写法</span></strong></span></h3><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">当然，还有一种更加优雅的方法来实现单例模式，那就是枚举写法：</span></p><pre class=\"brush:java;toolbar:false\">public&nbsp;enum&nbsp;Singleton&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;INSTANCE;\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;getName(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;name;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setName(String&nbsp;name){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n}</pre><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">使用枚举除了线程安全和防止反射强行调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象。因此，<a href=\"http://www.amazon.com/gp/product/B000WJOUPA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=B000WJOUPA&linkCode=as2&tag=job0ae-20\" title=\"Effective Java\" target=\"_blank\" class=\"external\">Effective Java</a>推荐尽可能地使用枚举来实现单例。</span></p><h3><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\">总结</span></strong></span></h3><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">这篇文章发出去以后得到许多反馈，这让我受宠若惊，觉得应该再写一点小结。代码没有一劳永逸的写法，只有在特定条件下最合适的写法。在不同的平台、不同的开发环境（尤其是jdk版本）下，自然有不同的最优解（或者说较优解）。<br/>比如枚举，虽然Effective Java中推荐使用，但是在Android平台上却是不被推荐的。在</span><a href=\"http://developer.android.com/training/articles/memory.html\" class=\"external\" target=\"_blank\" style=\"text-decoration: underline; font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">这篇Android Training</span></a><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">中明确指出：</span></p><blockquote><p><span style=\"color: rgb(128, 128, 128); font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">Enums often require more than twice as much memory as static constants. You should strictly avoid using enums on Android.</span></p></blockquote><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">再比如双重检查锁法，不能在jdk1.5之前使用，而在Android平台上使用就比较放心了（一般Android都是jdk1.6以上了，不仅修正了volatile的语义问题，还加入了不少锁优化，使得多线程同步的开销降低不少）。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">最后，不管采取何种方案，请时刻牢记单例的三大要点：</span></p><ul class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">线程安全</span></p></li><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">延迟加载</span></p></li><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">序列化与反序列化安全</span></p></li></ul><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p>',0,'设计模式 单例','单例模式要达到以下几个目的：确保某一个类只有一个实例这个类必须自行实例化并向整个系统提供这个实例因此，为了达到以上的几个目的，单例模式必须具有以下几个特点：单例类的构造方法为私有提供一个自身的静态私有成员变量提供一个共有的静态工厂方法单例模式的实现方式有很多种，它们各自适用的情况也不尽相同。饿汉法顾名思义，饿汉法就是在第一次引用该类的时候就创建对象实例，而不管实际是否需要创建。代码如下：publi...',11,18,'20161123/1479867467249.jpg'),(77,'JavaScript中的跨域访问','2016-11-08 13:18:35','<div><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">这里说的js跨域是指通过js在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。只要协议、域名、端口有任何一个不同，都被当作是不同的域。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">下表给出了相对http://store.company.com/dir/page.html同源检测的结果:</span></p><p><a href=\"http://images.cnitblog.com/blog/130623/201307/15184525-747de461b3b14f938b443e72ea25b25a.png\"><img title=\"QQ截图20130613230631\" src=\"/ueditor/jsp/upload/image/20161126/1480090197546094431.png\" alt=\"QQ截图20130613230631\" height=\"203\" width=\"532\"/></a></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">要解决跨域的问题，我们可以使用以下几种方法：</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>一、通过jsonp跨域</strong></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">比如，有个a.html页面，它里面的代码需要利用ajax获取一个不同域上的json数据，假设这个json数据地址是</span><a href=\"http://example.com/data.php\" style=\"text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">http://example.com/data.php</span></a><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">,那么a.html中的代码就可以这样：</span></p><p><a href=\"http://images.cnitblog.com/blog/130623/201307/15184526-bcc1971f27094439b746cb1f52a715be.png\"><img title=\"QQ截图20130613230631\" src=\"/ueditor/jsp/upload/image/20161126/1480090197593027842.png\" alt=\"QQ截图20130613230631\" height=\"110\" width=\"527\"/></a></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">我们看到获取数据的地址后面还有一个callback参数，按惯例是用这个参数名，但是你用其他的也一样。当然如果获取数据的jsonp地址页面不是你自己能控制的，就得按照提供数据的那一方的规定格式来操作了。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">因为是当做一个js文件来引入的，所以</span><a href=\"http://example.com/data.php\" style=\"text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">http://example.com/data.php</span></a><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">返回的必须是一个能执行的js文件，所以这个页面的php代码可能是这样的:</span></p><p><a href=\"http://images.cnitblog.com/blog/130623/201307/15184527-28a9558c3caa424683980a50b8371134.png\"><img title=\"QQ截图20130613230631\" src=\"/ueditor/jsp/upload/image/20161126/1480090197624067983.png\" alt=\"QQ截图20130613230631\" height=\"87\" width=\"362\"/></a></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">最终那个页面输出的结果是:</span></p><p><a href=\"http://images.cnitblog.com/blog/130623/201307/15184528-32bbea18197b4e35bb5f67480da1f367.png\"><img title=\"QQ截图20130613230631\" src=\"/ueditor/jsp/upload/image/20161126/1480090197640068116.png\" alt=\"QQ截图20130613230631\" height=\"34\" width=\"208\"/></a></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">所以通过</span><a href=\"http://example.com/data.php?callback=dosomething\" style=\"text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">http://example.com/data.php?callback=dosomething</span></a><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">得到的js文件，就是我们之前定义的dosomething函数,并且它的参数就是我们需要的json数据，这样我们就跨域获得了我们需要的数据。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">这样jsonp的原理就很清楚了，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">知道jsonp跨域的原理后我们就可以用js动态生成script标签来进行跨域操作了，而不用特意的手动的书写那些script标签。如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。</span></p><p><a href=\"http://images.cnitblog.com/blog/130623/201307/15184529-f4a5efe2881a40eebbdca2b463e264bf.png\"><img title=\"QQ截图20130613230631\" src=\"/ueditor/jsp/upload/image/20161126/1480090197687044921.png\" alt=\"QQ截图20130613230631\" height=\"87\" width=\"520\"/></a></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">原理是一样的，只不过我们不需要手动的插入script标签以及定义回掉函数。jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>2、通过修改document.domain来跨子域</strong></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">浏览器都有一个同源策略，其限制之一就是第一种方法中我们说的不能通过ajax的方法去请求不同源中的文档。 \r\n它的第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。有一点需要说明，不同的框架之间（父子或同辈），是能够获取到彼此的window对象的，但蛋疼的是你却不能使用获取到的window对象的属性和方法(html5中的postMessage方法是一个例外，还有些浏览器比如ie6也可以使用top、parent等少数几个属性)，总之，你可以当做是只能获取到一个几乎无用的window对象。比如，有一个页面，它的地址是</span><a href=\"http://www.example.com/a.html\" style=\"text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">http://www.example.com/a.html</span></a><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; ， 在这个页面里面有一个iframe，它的src是</span><a href=\"http://example.com/b.html\" style=\"text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">http://example.com/b.html</span></a><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的：</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; </span><a href=\"http://images.cnitblog.com/blog/130623/201307/15184530-8b5ff5011fc24c7a9949eac174a4dc73.png\"><img title=\"QQ截图20130613230631\" src=\"/ueditor/jsp/upload/image/20161126/1480090197749051455.png\" alt=\"QQ截图20130613230631\" height=\"160\" width=\"796\"/></a></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">这个时候，document.domain就可以派上用场了，我们只要把</span><a href=\"http://www.example.com/a.html\" style=\"text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">http://www.example.com/a.html</span></a><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> 和 </span><a href=\"http://example.com/b.html\" style=\"text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">http://example.com/b.html</span></a><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。例如：a.b.example.com\r\n 中某个文档的document.domain 可以设成a.b.example.com、b.example.com \r\n、example.com中的任意一个，但是不可以设成 \r\nc.a.b.example.com,因为这是当前域的子域，也不可以设成baidu.com,因为主域已经不相同了。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在页面 </span><a href=\"http://www.example.com/a.html\" style=\"text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">http://www.example.com/a.html</span></a><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> 中设置document.domain:</span></p><p><a href=\"http://images.cnitblog.com/blog/130623/201307/15184531-49f512a730204cab803ce03833e4b554.png\"><img title=\"QQ截图20130613230631\" src=\"/ueditor/jsp/upload/image/20161126/1480090197765038516.png\" alt=\"QQ截图20130613230631\" height=\"118\" width=\"554\"/></a></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在页面 </span><a href=\"http://example.com/b.html\" style=\"text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">http://example.com/b.html</span></a><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> 中也设置document.domain，而且这也是必须的，虽然这个文档的domain就是example.com,但是还是必须显示的设置document.domain的值：</span></p><p><a href=\"http://images.cnitblog.com/blog/130623/201307/15184533-f10eef95c6994d09bc2d595325f45759.png\"><img title=\"QQ截图20130613230631\" src=\"/ueditor/jsp/upload/image/20161126/1480090197812061226.png\" alt=\"QQ截图20130613230631\" height=\"52\" width=\"754\"/></a></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">这样我们就可以通过js访问到iframe中的各种属性和对象了。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">不过如果你想在</span><a href=\"http://www.example.com/a.html\" style=\"text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">http://www.example.com/a.html</span></a><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> 页面中通过ajax直接请求</span><a href=\"http://example.com/b.html\" style=\"text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">http://example.com/b.html</span></a><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">\r\n 页面，即使你设置了相同的document.domain也还是不行的，所以修改document.domain的方法只适用于不同子域的框架间的交互。如果你想通过ajax的方法去与不同子域的页面交互，除了使用jsonp的方法外，还可以用一个隐藏的iframe来做一个代理。原理就是让这个iframe载入一个与你想要通过ajax获取数据的目标页面处在相同的域的页面，所以这个iframe中的页面是可以正常使用ajax去获取你要的数据的，然后就是通过我们刚刚讲得修改document.domain的方法，让我们能通过js完全控制这个iframe，这样我们就可以让iframe去发送ajax请求，然后收到的数据我们也可以获得了。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>3、使用window.name来进行跨域</strong></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">比如：有一个页面a.html,它里面有这样的代码：</span></p><p><a href=\"http://images.cnitblog.com/blog/130623/201307/15184534-769ff1574c304d11accd26cbbbd1f9da.png\"><img title=\"QQ截图20130613230631\" src=\"/ueditor/jsp/upload/image/20161126/1480090197843028012.png\" alt=\"QQ截图20130613230631\" height=\"102\" width=\"399\"/></a></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">再看看b.html页面的代码：</span></p><p><a href=\"http://images.cnitblog.com/blog/130623/201307/15184535-fd6a9a0604754241a8f8947ced97b8e9.png\"><img title=\"QQ截图20130613230631\" src=\"/ueditor/jsp/upload/image/20161126/1480090197859087278.png\" alt=\"QQ截图20130613230631\" height=\"57\" width=\"302\"/></a></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">a.html页面载入后3秒，跳转到了b.html页面，结果为：</span></p><p><a href=\"http://images.cnitblog.com/blog/130623/201307/15184536-5eadbc78e1fc4c8bb573aefa486ca52c.png\"><img title=\"QQ截图20130613230631\" src=\"/ueditor/jsp/upload/image/20161126/1480090197952023070.png\" alt=\"QQ截图20130613230631\" height=\"373\" width=\"461\"/></a></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">我们看到在b.html页面上成功获取到了它的上一个页面a.html给window.name设置的值。如果在之后所有载入的页面都没对window.name进行修改的话，那么所有这些页面获取到的window.name的值都是a.html页面设置的那个值。当然，如果有需要，其中的任何一个页面都可以对window.name的值进行修改。注意，window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器，但一般是够用了。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">上面的例子中，我们用到的页面a.html和b.html是处于同一个域的，但是即使a.html与b.html处于不同的域中，上述结论同样是适用的，这也正是利用window.name进行跨域的原理。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">下面就来看一看具体是怎么样通过window.name来跨域获取数据的。还是举例说明。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">比如有一个</span><a href=\"http://www.example.com/a.html\" style=\"text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">www.example.com/a.html</span></a><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">页面,需要通过a.html页面里的js来获取另一个位于不同域上的页面</span><a href=\"http://www.cnblogs.com/data.html\" style=\"text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">www.cnblogs.com/data.html</span></a><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">里的数据。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">data.html页面里的代码很简单，就是给当前的window.name设置一个a.html页面想要得到的数据值。data.html里的代码：</span></p><p><a href=\"http://images.cnitblog.com/blog/130623/201307/15184538-f329d65db57d49c3b89bef6d413e34ad.png\"><img title=\"QQ截图20130613230631\" src=\"/ueditor/jsp/upload/image/20161126/1480090198046007199.png\" alt=\"QQ截图20130613230631\" height=\"57\" width=\"756\"/></a></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">那么在a.html页面中，我们怎么把data.html页面载入进来呢？显然我们不能直接在a.html页面中通过改变window.location来载入data.html页面，因为我们想要即使a.html页面不跳转也能得到data.html里的数据。答案就是在a.html页面中使用一个隐藏的iframe来充当一个中间人角色，由iframe去获取data.html的数据，然后a.html再去得到iframe获取到的数据。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">充当中间人的iframe想要获取到data.html的通过window.name设置的数据，只需要把这个iframe的src设为</span><a href=\"http://www.cnblogs.com/data.html\" style=\"text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">www.cnblogs.com/data.html</span></a><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">就行了。然后a.html想要得到iframe所获取到的数据，也就是想要得到iframe的window.name的值，还必须把这个iframe的src设成跟a.html页面同一个域才行，不然根据前面讲的同源策略，a.html是不能访问到iframe里的window.name属性的。这就是整个跨域过程。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">看下a.html页面的代码：</span></p><p><img src=\"/ueditor/jsp/upload/image/20161126/1480090198296079842.png\" alt=\"\" height=\"256\" width=\"760\"/></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">上面的代码只是最简单的原理演示代码，你可以对使用js封装上面的过程，比如动态的创建iframe,动态的注册各种事件等等，当然为了安全，获取完数据后，还可以销毁作为代理的iframe。网上也有很多类似的现成代码，有兴趣的可以去找一下。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">通过window.name来进行跨域，就是这样子的。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>4、使用HTML5中新引进的window.postMessage方法来跨域传送数据</strong></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">window.postMessage(message,targetOrigin)&nbsp; \r\n方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">调用postMessage方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符\r\n *&nbsp; 。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">上面所说的向其他window对象发送消息，其实就是指一个页面有几个框架的那种情况，因为每一个框架都有一个window对象。在讨论第二种方法的时候，我们说过，不同域的框架间是可以获取到对方的window对象的，而且也可以使用window.postMessage这个方法。下面看一个简单的示例，有两个页面</span></p><p><a href=\"http://images.cnitblog.com/blog/130623/201307/15184544-594f30a8bacd4da0a4a2293f63f53534.png\"><img title=\"QQ截图20130613230631\" src=\"/ueditor/jsp/upload/image/20161126/1480090198343003959.png\" alt=\"QQ截图20130613230631\" height=\"152\" width=\"691\"/></a></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;</span></p><p><a href=\"http://images.cnitblog.com/blog/130623/201307/15184545-4285b632b74c4abea9aba5ecb2587f5a.png\"><img title=\"QQ截图20130613230631\" src=\"/ueditor/jsp/upload/image/20161126/1480090198390037415.png\" alt=\"QQ截图20130613230631\" height=\"120\" width=\"437\"/></a></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">我们运行a页面后得到的结果:</span></p><p><a href=\"http://images.cnitblog.com/blog/130623/201307/15184547-b7a7e7b771054807b112248f39201e53.png\"><img title=\"QQ截图20130613230631\" src=\"/ueditor/jsp/upload/image/20161126/1480090198421068772.png\" alt=\"QQ截图20130613230631\" height=\"300\" width=\"449\"/></a></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">我们看到b页面成功的收到了消息。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">使用postMessage来跨域传送数据还是比较直观和方便的，但是缺点是IE6、IE7不支持，所以用不用还得根据实际需要来决定。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>结语：</strong></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">除了以上几种方法外，还有flash、在服务器上设置代理页面等跨域方式，这里就不做介绍了。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">以上四种方法，可以根据项目的实际情况来进行选择应用，个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。</span></p></div><p><br/></p>',0,'js 跨域','这里说的js跨域是指通过js在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。只要协议、域名、端口有任何一个不同，都被当作是不同的域。下表给出了相对http://store.company.com/dir/page.html同源检测的结果:要解决跨域的问题，我们可以使用以下几种方法：一、通过jsonp跨域在js中，我...',22,12,'20161126/1480090764812.jpg'),(78,'Struts2与SpringMVC比较','2016-11-08 15:41:59','<p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">总的来说<strong>SpringMVC</strong><strong>是</strong><strong>基于方法</strong>的模式，而<strong>Struts是基于类</strong>的模式。</span><img src=\"/ueditor/jsp/upload/image/20161125/1480088015999062776.png\" alt=\"\" height=\"228\" width=\"726\"/><br/></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Struts2和SpringMVC是比较流行的MVC框架，二者的工作流程大体相似，从下面两张图就可以看出。 </span></p><h2><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">SpringMVC工作流程图 </span></strong></h2><p><img src=\"/ueditor/jsp/upload/image/20161125/1480088355796002558.png\" alt=\"\"/><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> &nbsp;</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> <strong>Spring MVC工作时序图 </strong><br/></span></p><p><img src=\"/ueditor/jsp/upload/image/20161125/1480088355921097096.png\" alt=\"\"/><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> &nbsp;</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> <strong>SpringMVC的工作流程描述</strong> &nbsp;</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> &nbsp; &nbsp; &nbsp;&nbsp;1. 用户向服务器发送请求，请求被Spring前端控制Servelt DispatcherServlet捕获； &nbsp;</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp;&nbsp;&nbsp; 2.&nbsp;DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回； </span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> &nbsp; &nbsp;&nbsp;&nbsp; 3.&nbsp;DispatcherServlet根据获得的Handler，选择一个合适的HandlerAdapter。（ <strong>附注</strong> ：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(...)方法） &nbsp;</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp; &nbsp; 4. 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： </span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp; &nbsp;&nbsp;HttpMessageConveter：将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息 </span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp; &nbsp;&nbsp;数据转换：对请求消息进行数据转换。如String转换成Integer、Double等 </span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp; &nbsp;&nbsp;数据根式化：对请求消息进行数据格式化。如将字符串转换成格式化数字或格式化日期等 </span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp; &nbsp;&nbsp;数据验证：验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 </span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp;&nbsp;&nbsp; 5. &nbsp;Handler执行完成后，向DispatcherServlet&nbsp;返回一个ModelAndView对象； </span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp;&nbsp;&nbsp; 6. &nbsp;根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet&nbsp;； </span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp;&nbsp;&nbsp; 7.&nbsp;ViewResolver结合Model和View，来渲染视图 </span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp; &nbsp; 8. 将渲染结果返回给客户端。 </span></p><h2><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Strut2的体系结构如图所示： </span></h2><p><img src=\"/ueditor/jsp/upload/image/20161125/1480088356015063234.png\" alt=\"\" height=\"602\" width=\"514\"/><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> &nbsp;</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> 从图中可以看出，一个请求在Struts2框架中的处理大概分为以下几个步骤： &nbsp;</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">1、客户端初始化一个指向Servlet容器（例如Tomcat）的请求； </span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">2、这个请求经过一系列的过滤器（Filter）（这些过滤器中有一个叫做ActionContextCleanUp的可选过滤器，这个过滤器对于Struts2和其他框架的集成很有帮助，例如：SiteMeshPlugin）； </span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">3、接着StrutsPrepareAndExecuteFilter被调用，StrutsPrepareAndExecuteFilter询问ActionMapper来决定这个请求是否需要调用某个Action； </span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">4、如果ActionMapper决定需要调用某个Action，StrutsPrepareAndExecuteFilter把请求的处理交给ActionProxy； </span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">5、ActionProxy通过ConfigurationManager询问框架的配置文件，找到需要调用的Action类； </span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">6、ActionProxy创建一个ActionInvocation的实例。 </span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">7、ActionInvocation实例使用命名模式来调用，在调用Action的过程前后，涉及到相关拦截器（Intercepter）的调用。 </span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">8、一旦Action执行完毕，ActionInvocation负责根据struts.xml中的配置找到对应的返回结果。返回结果通常是（但不总是，也可能是另外的一个Action链）一个需要被表示的JSP或者FreeMarker的模版。在表示的过程中可以使用Struts2框架中继承的标签。在这个过程中需要涉及到ActionMapper。 <br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">以上是从宏观上对比下二者的工作流程，下面针对细节对比二者的不同。 <br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>Spring MVC和Struts2的区别：</strong></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>1. 机制：</strong></span><br/></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Spring MVC 的入口是Servlet，而Struts2的入口是Filter，因为Servlet和Filter是不同的。这样就导致了二者机制的不同。</span><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></strong></p><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">2. 性能： <br/></span></strong></p><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span></strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">spring会稍微比struts快。 spring mvc是基于方法的设计 ， 而sturts是基于类 ，每次发一次请求都会实例一个action，每个action都会被注入属性，而spring基于方法，粒度更细，但要小心把握像在servlet控制数据一样。spring3mvc是方法级别的拦截，拦截到方法后根据参数上的注解，把request数据注入进去，在spring3mvc中，一个方法对应一个request上下文。而struts2框架是类级别的拦截，每次来了请求就创建一个Action，然后调用settergetter方法把request中的数据注入； struts2实际上是通过setter getter方法与request打交道的 ，而 springmvc 不用 setter getter 方法 ；struts2中，一个Action对象对应一个request上下文。 &nbsp;</span></p><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">3. 实现restful： </span></strong></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> springmvc是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应，所以说从架构本身上 spring3 mvc就容易实现restful url 。 struts2 是类级别的拦截，一个类对应一个 request 上下文；实现 restfulurl 要费劲，因为 struts2 action 的一个方法可以对应一个 url ；而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。 &nbsp;</span></p><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">4. 数据共享： </span></strong></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">struts是在接受参数的时候，可以用属性来接受参数，这就说明参数是让多个方法共享的。 </span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">spring3 mvc的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架方法之间不共享变量 </span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>5.处理Ajax请求：</strong></span><br/></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">spring3 mvc的验证也是一个亮点，支持JSR303， 处理ajax的请求更是方便 ，只需一个注解 @ResponseBody，然后直接返回响应文本即可。送上一段代码： &nbsp;&nbsp; </span></p><pre class=\"brush:java;toolbar:false\">@ResponseBody\r\n@RequestMapping(&quot;/delUser&quot;)\r\npublic&nbsp;String&nbsp;delUser(String&nbsp;id,&nbsp;HttpServletResponse&nbsp;response){\r\n&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;result&nbsp;=&quot;{/&quot;result/&quot;:/&quot;error/&quot;}&quot;;\r\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(userManager.delUser(id))&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&quot;{/&quot;result/&quot;:/&quot;success/&quot;}&quot;;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;//spring3mvc的验证也是一个亮点，支持JSR303，处理ajax的请求更是方便，只需一个注解@ResponseBody\r\n&nbsp;&nbsp;&nbsp;&nbsp;//@ResponseBody代替了下面的代码&nbsp;\r\n&nbsp;&nbsp;&nbsp;/*PrintWriterout&nbsp;=&nbsp;null;\r\n&nbsp;&nbsp;&nbsp;&nbsp;response.setContentType(&quot;application/json&quot;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;try{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out=&nbsp;response.getWriter();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.write(result);\r\n&nbsp;&nbsp;&nbsp;&nbsp;}catch&nbsp;(IOException&nbsp;e)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();\r\n&nbsp;&nbsp;&nbsp;&nbsp;}*/\r\n}</pre><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">6. Interceptor的实现机制： </span></strong></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">struts有以自己的interceptor机制， springmvc用的是独立的AOP方式 。这样导致struts的配置文件量还是比springmvc大，虽然struts的配置能继承，所以我觉得论使用上来讲，spring mvc使用更加简洁，开发效率Spring MVC确实比struts2高。 &nbsp;</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span><br/></p>',0,'SpringMVC Struts 比较','总的来说SpringMVC是基于方法的模式，而Struts是基于类的模式。Struts2和SpringMVC是比较流行的MVC框架，二者的工作流程大体相似，从下面两张图就可以看出。 SpringMVC工作流程图    Spring MVC工作时序图    SpringMVC的工作流程描述         1. 用户向服务器发送请求，请求被Spring前端控制Servelt DispatcherSe...',24,17,'20161126/1480099192512.jpg'),(80,'Hibernate中的Session','2016-11-17 17:24:27','<p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Hibernate的透明持久化用起来非常舒服，有时甚至忘记了数据库的存在。我身边的朋友经常会分不清save、saveOrUpdate、update的区别，lock、merge、replicate、refresh、evict甚至不知道是干什么用的。而且关于实体对象的生命周期也有很多概念不清，分不清transient、persistent、detached的区别，只是知道PO、VO这样的通俗叫法。其实这些概念都很简单，Hibernate的javadoc写的都很清楚，只需看看就能明白。所以我花了些时间将Hibernate\r\n \r\n3.1.2中session的javadoc部分翻译了一下，旨在让那些因为Hibernate的“透明”而忘记了它基本概念的人们停下来再看看这些概念</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">public interface <strong>Session</strong></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; extends Serializable</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Java应用程序与hibernate之间的主要运行时接口。它是抽象了持久化服务概念的核心抽象API类。<br/><br/></span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Session</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">的生命周期绑定在一个物理的事务（tansaction）上面。（长的事务可能跨越多个数据库事物。）<br/><br/></span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Session</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">的主要功能是提供对映射的实体类实例的创建，读取和删除操作。实例可能以下面三种状态存在：<br/><br/><em>自由状态（transient）:</em> 不曾进行持久化，未与任何</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Session</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">相关联<br/><em>持久化状态（persistent）:</em> 仅与一个</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Session</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">相关联<br/><em>游离状态（detached）:</em> 已经进行过持久化，但当前未与任何</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Session</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">相关联<br/><br/>游离状态的实例可以通过调用</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">save()</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">、</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">persist()</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">或者</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">saveOrUpdate()</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">方法进行持久化。持久化实例可以通过调用</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> delete()</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">变成游离状态。通过</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">get()</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">或</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">load()</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">方法得到的实例都是持久化状态的。游离状态的实例可以通过调用 </span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">update()</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">、0</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">saveOrUpdate()</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">、</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">lock()</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">或者</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">replicate()</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">进行持久化。游离或者自由状态下的实例可以通过调用</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">merge()</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">方法成为一个新的持久化实例。<br/><br/></span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">save()</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">和</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">persist()</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">将会引发SQL的</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">INSERT</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">，</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">delete()</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">会引发SQL</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">DELETE</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">，而</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">update()</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">或</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">merge()</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">会引发SQL</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">UPDATE</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">。对<em>持久化（persistent）</em>实例的修改在刷新提交的时候会被检测到，它也会引起SQL</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">UPDATE</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">。</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">saveOrUpdate()</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">或者</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">replicate()</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">会引发SQL</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">INSERT</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">或者</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">UPDATE</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">。<br/><br/>其具体实现并不一定是线程安全的。每个线程/事务应该从一个</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">SessionFactory</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">获取自己的session实例。<br/><br/>如果其持久化对象类是可序列化的，则</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Session</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">实例也是可序列化的。<br/><br/>一个典型的事务应该使用下面的形式：</span></p><pre class=\"brush:java;toolbar:false\">&nbsp;Session&nbsp;sess&nbsp;=&nbsp;factory.openSession();\r\n&nbsp;Transaction&nbsp;tx;\r\n&nbsp;try&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx&nbsp;=&nbsp;sess.beginTransaction();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//do&nbsp;some&nbsp;work\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx.commit();\r\n&nbsp;}\r\n&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(tx!=null)&nbsp;tx.rollback();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;e;\r\n&nbsp;}\r\n&nbsp;finally&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sess.close();\r\n&nbsp;}</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">如果</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Session</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">抛出了异常, 事务必须回滚而session会被废弃。在异常发生后</span><tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Session</span></tt><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">的内部状态可能会与数据库失去同步。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Session接口中的常用方法</span></strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">：</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span></p><p style=\"\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong><br/></strong></span></p><p style=\"\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>save()和persist()方法</strong><br/>Session的save()方法使一个临时对象转变为持久化对象。它完成以下操作：<br/>(1)将临时对象加入到Session缓存中，使其进入持久化状态。<br/>(2)选用映射文件指定的标识符生成器，为持久化对象分配唯一的OID。<br/>(3)计划执行一个insert语句。&nbsp;&nbsp;<br/>Session的save()方法是用来持久化临时对象的。不应将持久化对象或游离对象传递给save()方法。<br/>若将持久化对象传递给save()方法，则该步保存操作是多余的。<br/>若将游离对象传递给save()方法，则会重新生成OID，再保存一次。</span></p><p style=\"\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">Session的persist()方法与save()方法类似，也能将临时对象转变为持久化对象。<br/>persist()方法与save()方法的区别在于：<br/>persist()方法不保证立即为持久化对象的OID赋值，而是有可能在Session清理缓存的时候才为OID赋值。<br/>此外，如果是在事物边界以外调用persist()方法，则该方法不会计划执行insert语句。而save()方法不论是在事物边界以外还是以内，都会计划执行insert语句。</span></p><p style=\"\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong><br/></strong></span></p><p style=\"\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>load()与get()方法</strong><br/>Session的load()与get()方法都能从根据给定的OID从</span><a href=\"http://lib.csdn.net/base/mysql\" class=\"replace_word\" title=\"MySQL知识库\" target=\"_blank\" style=\"color: rgb(223, 52, 52); font-weight: bold; text-decoration: underline; font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">数据库</span></a><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">中加载一个持久化对象，这两个方法的区别在于：<br/>(1)当数据库中不存在与OID对应的记录时，load()方法抛出org.</span><a href=\"http://lib.csdn.net/base/javaee\" class=\"replace_word\" title=\"Java EE知识库\" target=\"_blank\" style=\"color: rgb(223, 52, 52); font-weight: bold; text-decoration: underline; font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">hibernate</span></a><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">.ObjectNotFoundException异常，而get()方法返回为null。<br/>(2)load方法采用配置的加载策略(默认为延迟加载)，而get()方法则会忽略配置，总是采用立即加载方法。</span></p><p style=\"\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong><br/></strong></span></p><p style=\"\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>update()方法</strong><br/>Session的update()方法使一个游离对象转变为持久化对象。它完成以下操作：<br/>(1)将游离对象加入到Session缓存中，使其转变为持久化对象。<br/>(2)计划执行一个update语句。<br/>当update()方法关联一个游离对象时，若在Session的缓存中已存在相同的OID的对象时，会抛出异常。</span></p><p style=\"\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">疑问：如果数据库总没有对应的记录，会产生异常？ update语句如果没有记录更新是不会报错的呀？</span></p><p style=\"\"><br/></p><p style=\"\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>saveOrUpdate()方法</strong><br/>Session的saveOrUpdate()方法同时包含了save()方法与update()方法的功能，如果传入的参数是临时对象，就调用save()方法；如果传入的参数是游离对象，就调用update()方法。HIbernate根据对象的OID,version版本属性等来判断参数是临时对象还是游离对象。</span></p><p style=\"\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong><br/></strong></span></p><p style=\"\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>merge()方法</strong><br/>Session的merge()方法能够将一个游离对象的属性复制到一个持久化对象中。其处理流程如下：<br/>(1)根据游离对象的OID到Session缓存中查找匹配的持久化对象。若找到匹配的持久化对象，则将游离对象的属性复制到持久化对象中，计划实行一条update语句，然后返回持久化对象的引用。<br/>(2)如果在Session的缓存中没有找到与游离对象OID一致的持久化对象，那么就试图根据该OID从数据库中加载持久化对象。如果数据库中存在匹配的持久化对象，则将游离对象的属性复制到刚加载的持久化对象中，计划实行一条update语句，然后返回持久化对象的引用。<br/>(3)如果数据库中也不存在or对象是临时对象时，则会新建一个对象，将属性赋值到该新建对象中，再持久化新建对象，最后返回新建对象的引用。</span></p><p style=\"\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">merger()和<strong>saveOrUpdate()的区别：</strong></span></p><p style=\"\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>调用完meger（）对象仍然是脱管状态。</strong></span></p><p style=\"\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong><br/></strong></span></p><p style=\"\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>delete()方法</strong><br/>Session的delete()方法用于从数据库中删除一个</span><a href=\"http://lib.csdn.net/base/javaee\" class=\"replace_word\" title=\"Java EE知识库\" target=\"_blank\" style=\"color: rgb(223, 52, 52); font-weight: bold; text-decoration: underline; font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">Java</span></a><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">对象。delete()方法既可以删除持久化对象，也可以删除游离对象。其处理过程如下：<br/>(1)如果传入的参数是游离对象，则先使游离对象与Session关联，使它变为持久化对象。如果参数是持久化对象，则忽略该步。<br/>(2)计划执行一个delete语句。<br/>(3)把对象从Session缓存中删除，该对象进入删除状态。</span></p><p style=\"\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><br/></span></p><p style=\"\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>replicate()方法</strong><br/>Session的replicate()方法能够将一个数据库中的对象复制到另一个数据库中。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span><br/></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>Session缓存（一级缓存）</strong><br/></span><br/></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在Session接口的实现中包含了一系列的Java集合，这些集合构成了Session缓存。只要Session实例没有结束生命周期，且没有清理缓存，那么存放在它缓存中的对象也不会结束生命周期。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Session缓存能够减少Hibernate应用程序访问数据库的频率。</span></p>',0,'Session 缓存','Hibernate的透明持久化用起来非常舒服，有时甚至忘记了数据库的存在。我身边的朋友经常会分不清save、saveOrUpdate、update的区别，lock、merge、replicate、refresh、evict甚至不知道是干什么用的。而且关于实体对象的生命周期也有很多概念不清，分不清transient、persistent、detached的区别，只是知道PO、VO这样的通俗叫法。其实...',15,15,'20161126/1480099068965.jpg'),(88,'Java中变量的初始化及默认值','2016-11-20 23:21:14','<p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">Java语言要求变量遵循先定义，再初始化，然后使用的规则。</span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">变量的初始化是自从变量定义以后，首次给它赋初值的过程。</span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">&nbsp;</span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><strong>对于类的成员变量。不管程序有没有显示的初始化，Java &nbsp;虚拟机都会先自动给它初始化为默认值。</strong></span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">规则为：</span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; white-space: pre;\"></span>1、整数类型（byte、short、int、long）的基本类型变量的默认值为0。</span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; white-space: pre;\"></span>2、单精度浮点型（float）的基本类型变量的默认值为0.0f。</span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; white-space: pre;\"></span>3、双精度浮点型（double）的基本类型变量的默认值为0.0d。</span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; white-space: pre;\"></span>4、字符型（char）的基本类型变量的默认为 “/u0000”。</span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; white-space: pre;\"></span>5、布尔性的基本类型变量的默认值为 false。</span></p><p style=\"font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(51, 51, 51);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; white-space: pre;\"></span>6、</span><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\">引用类型的变量是默认值为 null</span><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(51, 51, 51);\">。</span><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\">内部的字段默认值也为null</span></span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; white-space: pre;\"></span>7、数组引用类型的变量的默认值为 null。春关键数组变量的实例后，如果没有没有显示的为每个元素赋值，Java 就会把该数组的所有元素初始化为其相应类型的默认值。</span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">&nbsp;</span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><strong>局部变量初始化</strong></span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">&nbsp;</span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">局部变量声明以后，Java 虚拟机不会自动的为它初始化为默认值。因此对于局部变量，必须先经过显示的初始化，才能使用它。</span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">如果编译器确认一个局部变量在使用之前可能没有被初始化，编译器将报错。</span></p><pre class=\"brush:java;toolbar:false\">public&nbsp;class&nbsp;Test{\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;method(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;a;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a++;//编译出错，变量a&nbsp;必须初始化\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(a);\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;method2(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;x&nbsp;=&nbsp;(int)(Math.random()&nbsp;*&nbsp;100);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;y;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;z;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(x&nbsp;&gt;&nbsp;50){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;9;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;=&nbsp;y&nbsp;+&nbsp;x;//编译出错，变量y可能没有被初始化\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;\r\n}</pre><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">如果局部变量没有被初始化，并且在方法中一直没有被使用，则编译和运行都会通过。</span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">&nbsp;</span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><strong>为什么 Java 虚拟机会自动初始化类的成员变量，却要求局部变量必须显示的初始化？</strong></span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">&nbsp;</span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">1、对于局部变量，很有可能是程序员疏忽，忘记了初始化局部变量，Java 编译器在编译阶段强制要求程序员给局部变量赋初始值，可避免潜在的威胁。</span></p><p style=\"color:rgb(51,51,51); font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">2、对于成员变量，Java\r\n \r\n语言提供了多种的初始化的途径。可以在声明时显示初始化，也可以在构造方法中初始化（适用于实例变量），还可以在静态代码块中初始化（适用于静态变量）。假如程序员没有显示的初始化成员变量，Java\r\n 语言则认为这些变量的初始值刚好和该数据类型的默认值相同，因此提供自动初始化的功能，以此简化编程。</span></p><p><br/></p>',1,'变量 初始化 默认值','Java语言要求变量遵循先定义，再初始化，然后使用的规则。变量的初始化是自从变量定义以后，首次给它赋初值的过程。 对于类的成员变量。不管程序有没有显示的初始化，Java  虚拟机都会先自动给它初始化为默认值。规则为：1、整数类型（byte、short、int、long）的基本类型变量的默认值为0。2、单精度浮点型（float）的基本类型变量的默认值为0.0f。3、双精度浮点型（double）的基本...',46,10,'20161123/1479867336374.jpg'),(89,'spring MVC返回数据到页面的几种方式 ','2016-11-20 23:25:34','<p><span style=\"font-size: 14px;\"></span></p><p><span style=\"font-size: 14px;\">Spring MVC返回数据到页面有几种不同的方式，它们各自适用的情况也不同，下面简单总结一下。</span></p><p><span style=\"font-size: 14px;\">对于每种方式都给出Controller中的相应方法。</span></p><p><span style=\"font-size: 14px;\">首先还是页面user_add.jsp。它既是发出请求的页面，也是接收返回结果的页面：</span></p><pre class=\"brush:html;toolbar:false\">&lt;%@&nbsp;page&nbsp;language=&quot;java&quot;&nbsp;import=&quot;java.util.*&quot;&nbsp;contentType=&quot;text/html;charset=utf-8&quot;%&gt;\r\n&lt;html&gt;\r\n&nbsp;&nbsp;&lt;head&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;&lt;/title&gt;\r\n&nbsp;&nbsp;&lt;/head&gt;\r\n&nbsp;&nbsp;&lt;body&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;添加用户信息4&lt;/h1&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;form&nbsp;action=&quot;user/add4.do&quot;&nbsp;method=&quot;post&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;	&lt;input&nbsp;type=&quot;submit&quot;&nbsp;value=&quot;提交&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;${personId&nbsp;}\r\n&nbsp;&nbsp;&lt;/body&gt;\r\n&lt;/html&gt;</pre><p><span style=\"font-size: 14px;\">1、通过request对象：</span></p><pre class=\"brush:java;toolbar:false\">@RequestMapping(&quot;/add.do&quot;)\r\npublic&nbsp;String&nbsp;add(HttpServletRequest&nbsp;request){\r\n	request.setAttribute(&quot;personId&quot;,12);\r\n	return&nbsp;&quot;user_add&quot;;\r\n}</pre><p><span style=\"font-size: 14px;\">2、通过ModelAndView对象：</span></p><pre class=\"brush:java;toolbar:false\">@RequestMapping(&quot;/add.do&quot;)\r\npublic&nbsp;ModelAndView&nbsp;add(){\r\n	ModelAndView&nbsp;mav&nbsp;=&nbsp;new&nbsp;ModelAndView(&quot;user_add&quot;);\r\n	mav.addObject(&quot;personId&quot;,&nbsp;12);\r\n	return&nbsp;mav;\r\n}</pre><p><span style=\"font-size: 14px;\">3、通过Model对象：<br/></span></p><pre class=\"brush:java;toolbar:false\">@RequestMapping(&quot;/add.do&quot;)\r\npublic&nbsp;String&nbsp;add(Model&nbsp;model){\r\n	model.addAttribute(&quot;personId&quot;,&nbsp;12);\r\n	return&nbsp;&quot;user_add&quot;;\r\n}</pre><p><span style=\"font-size: 14px;\">4、通过Map对象：<br/></span></p><pre class=\"brush:java;toolbar:false\">@RequestMapping(&quot;/add.do&quot;)\r\npublic&nbsp;String&nbsp;add(Map&lt;String,Object&gt;&nbsp;map){\r\n	map.put(&quot;personId&quot;,&nbsp;12);\r\n	return&nbsp;&quot;user_add&quot;;\r\n}</pre><p><br/></p>',1,'SpringMVC 返回数据','Spring MVC返回数据到页面有几种不同的方式，它们各自适用的情况也不同，下面简单总结一下。对于每种方式都给出Controller中的相应方法。首先还是页面user_add.jsp。它既是发出请求的页面，也是接收返回结果的页面：<%@ page language=\"java\" import=\"java.util.*\" contentType=\"text/html;charset=utf-8\"%...',27,13,'20161122/1479824027609.jpg'),(90,'spring MVC 获取请求参数的几种方式','2016-11-20 23:28:56','<p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Spring MVC的请求参数获取非常方便，因为Spring可以对请求参数进行封装（JavaBean），也可以在后台直接通过方法形参来获取，Spring提供了一些注解来简化我们的工作，比如@RequestParam，@PathVariable等，下面将详细介绍。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">首先我们需要编写发起请求的jsp页面user_add.jsp，该页面只有一个form表单，当我们提交表单时，它就会向后台发出一个HTTP请求，并将form表单中的内容作为参数传递到后台。页面代码如下：</span></p><pre class=\"brush:html;toolbar:false\">&lt;%@&nbsp;page&nbsp;language=&quot;java&quot;&nbsp;import=&quot;java.util.*&quot;&nbsp;contentType=&quot;text/html;charset=utf-8&quot;%&gt;\r\n&lt;html&gt;\r\n&nbsp;&nbsp;&lt;head&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;&lt;/title&gt;\r\n&nbsp;&nbsp;&lt;/head&gt;\r\n&nbsp;&nbsp;&lt;body&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;添加用户信息1&lt;/h1&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;form&nbsp;action=&quot;user/add.do&quot;&nbsp;method=&quot;post&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;	账号：&lt;input&nbsp;type=&quot;text&quot;&nbsp;name=&quot;username&quot;&gt;&lt;br&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;	密码：&lt;input&nbsp;type=&quot;password&quot;&nbsp;name=&quot;password&quot;&gt;&lt;br&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;	&lt;input&nbsp;type=&quot;submit&quot;&nbsp;value=&quot;提交&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;\r\n&nbsp;&nbsp;&lt;/body&gt;\r\n&lt;/html&gt;</pre><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">1、通过request对象获取（<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">request.getParam</span>eter</span>()方法）</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">UserController类的add方法：</span></p><pre class=\"brush:java;toolbar:false\">@RequestMapping(&quot;/add.do&quot;)\r\npublic&nbsp;String&nbsp;add(HttpServletRequest&nbsp;request){\r\n	System.out.println(&quot;账号：&quot;+request.getParameter(&quot;username&quot;));\r\n	System.out.println(&quot;密码：&quot;+request.getParameter(&quot;password&quot;));\r\n	return&nbsp;&quot;user_add&quot;;\r\n}</pre><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">2、直接设置参数，通过@RequestParam注解绑定请求参数到方法入参：</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">注意：当请求参数username不存在时会有异常发生,可以通过设置属性required=false解决,例如: @RequestParam(value=&quot;username&quot;, required=false)</span></p><pre class=\"brush:java;toolbar:false\">@RequestMapping(&quot;/add.do&quot;)\r\npublic&nbsp;String&nbsp;add(@RequestParam(&quot;username&quot;)String&nbsp;userName,@RequestParam(&quot;password&quot;)String&nbsp;passWord){\r\n	System.out.println(&quot;账号：&quot;+userName);\r\n	System.out.println(&quot;密码：&quot;+passWord);\r\n	return&nbsp;&quot;user_add&quot;;\r\n}</pre><p><span style=\"white-space: pre; font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">3、通过JavaBean对象（如User）或类型对象（如Integer）</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">注意：表单中标签的name属性值必须与类的属性名称一致</span></span></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">修改user_add.jsp如下：</span></p><pre class=\"brush:html;toolbar:false\">&lt;%@page&nbsp;language=&quot;java&quot;&nbsp;import=&quot;java.util.*&quot;&nbsp;contentType=&quot;text/html;charset=utf-8&quot;%&gt;\r\n&lt;html&gt;\r\n&nbsp;&nbsp;&lt;head&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;&lt;/title&gt;\r\n&nbsp;&nbsp;&lt;/head&gt;\r\n&nbsp;&nbsp;&lt;body&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;form&nbsp;action=&quot;user/add.do&quot;&nbsp;method=&quot;post&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;	编号：&lt;input&nbsp;type=&quot;text&quot;&nbsp;name=&quot;userId&quot;&gt;&lt;br&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;	姓名：&lt;input&nbsp;type=&quot;text&quot;&nbsp;name=&quot;userName&quot;&gt;&lt;br&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;	性别：&lt;input&nbsp;type=&quot;text&quot;&nbsp;name=&quot;userSex&quot;&gt;&lt;br&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;	&lt;input&nbsp;type=&quot;submit&quot;&nbsp;value=&quot;提交&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;\r\n&nbsp;&nbsp;&lt;/body&gt;\r\n&lt;/html&gt;</pre><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">添加User类：</span></p><pre class=\"brush:java;toolbar:false\">public&nbsp;class&nbsp;User{\r\n	\r\n	private&nbsp;Integer&nbsp;userId;\r\n	private&nbsp;String&nbsp;userName;\r\n	private&nbsp;String&nbsp;userSex;\r\n	//此处省略getter&nbsp;setter方法\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;toString(){\r\n		return&nbsp;&quot;编号：&quot;+userId+&quot;,姓名：&quot;+userName+&quot;,性别：&quot;+userSex;\r\n	}\r\n}</pre><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">相应UserController中的add方法：</span></p><pre class=\"brush:java;toolbar:false\">@RequestMapping(&quot;/add.do&quot;)\r\npublic&nbsp;String&nbsp;add(User&nbsp;user){\r\n	System.out.println(&quot;用户：&quot;+user);\r\n	return&nbsp;&quot;user_add&quot;;\r\n}	</pre><p>4.<span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">通过@PathVariable注解获取路径中的参数，如下：</span></p><pre class=\"brush:java;toolbar:false\">@RequestMapping(value=&quot;/addUser/{userNname}/{passWord}&quot;,method=RequestMethod.GET)\r\npublic&nbsp;String&nbsp;addUser4(@PathVariable&nbsp;String&nbsp;userName,@PathVariable&nbsp;String&nbsp;passWord)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;userNname&nbsp;is:&quot;+userNname);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;passWord&nbsp;is:&quot;+passWord);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;index&quot;;\r\n}</pre><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span><br/></p><p><br/></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><br/></span></p>',0,'SpringMVC 获取请求参数','Spring MVC的请求参数获取非常方便，因为Spring可以对请求参数进行封装（JavaBean），也可以在后台直接通过方法形参来获取，Spring提供了一些注解来简化我们的工作，比如@RequestParam，@PathVariable等，下面将详细介绍。首先我们需要编写发起请求的jsp页面user_add.jsp，该页面只有一个form表单，当我们提交表单时，它就会向后台发出一个HTTP请...',10,13,'20161122/1479823757863.jpg'),(91,'Spring MVC基于注解方式实现简单HelloWorld','2016-11-20 23:35:35','<p style=\"margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\"><span style=\"font-size: 14px;\">实现Spring </span><span style=\"font-size: 14px;\">MVC有两种不同的方式：基于XML配置文件和基于注解。</span></p><p style=\"margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\"><span style=\"font-size: 14px;\">上篇博客介绍了基于XML配置文件的方式，这里我们使用基于注解的方式来实现。</span></p><p style=\"margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\"><span style=\"font-size: 14px;\">下面只重点介绍与XML配置文件方式不同的两个地方：Spring配置文件（springmvc-servlet.xml）和Controller类。</span></p><p style=\"margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\"><span style=\"font-size: 14px;\">其中，springmvc-servlet,xml文件内容：</span></p><pre class=\"brush:xml;toolbar:false\">&lt;?xml&nbsp;version=&quot;1.0&quot;&nbsp;encoding=&quot;UTF-8&quot;?&gt;\r\n&lt;beans&nbsp;xmlns=&quot;http://www.springframework.org/schema/beans&quot;\r\n	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\r\n	xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\r\n	xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\r\n	xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;\r\n	xsi:schemaLocation=&quot;http://www.springframework.org/schema/mvc&nbsp;http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd\r\n		http://www.springframework.org/schema/beans&nbsp;http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\r\n		http://www.springframework.org/schema/context&nbsp;http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;\r\n	\r\n	&lt;!--&nbsp;加载springmvc注解驱动&nbsp;--&gt;\r\n	&lt;mvc:annotation-driven/&gt;\r\n	\r\n	&lt;!--&nbsp;扫描器&nbsp;(默认扫描的包com.xjc)--&gt;\r\n	&lt;context:component-scan&nbsp;base-package=&quot;com.xjc&quot;/&gt;\r\n	\r\n	&lt;!--&nbsp;配置视图解析器&nbsp;--&gt;\r\n	&lt;bean&nbsp;class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;\r\n		&lt;!--&nbsp;前缀&nbsp;--&gt;\r\n		&lt;property&nbsp;name=&quot;prefix&quot;&nbsp;value=&quot;/&quot;&gt;&lt;/property&gt;\r\n		&lt;!--&nbsp;后缀&nbsp;--&gt;\r\n		&lt;property&nbsp;name=&quot;suffix&quot;&nbsp;value=&quot;.jsp&quot;&gt;&lt;/property&gt;\r\n	&lt;/bean&gt;\r\n&lt;/beans&gt;</pre><p><span style=\"font-family: Arial; font-size: 14px;\">控制器HelloController类（注意：这里不再继承AbstractController类，而是通过添加注解@Controller的方式来说明它属于控制器）：</span></p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.xjc.controller;\r\nimport&nbsp;org.springframework.stereotype.Controller;\r\nimport&nbsp;org.springframework.ui.Model;\r\nimport&nbsp;org.springframework.web.bind.annotation.RequestMapping;\r\n\r\n@Controller\r\npublic&nbsp;class&nbsp;HelloController{\r\n	\r\n	@RequestMapping(value=&quot;/hello.do&quot;)\r\n	public&nbsp;String&nbsp;toIndex(String&nbsp;hello,Model&nbsp;model)&nbsp;{\r\n		\r\n		model.addAttribute(&quot;helloworld&quot;,&nbsp;&quot;hello&nbsp;&quot;+hello);\r\n		return&nbsp;&quot;index&quot;;\r\n	}\r\n\r\n}</pre><div style=\"top:0px\"><p style=\"margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\"><span style=\"font-size: 14px;\">此外的步骤及运行效果均与基于XML文件的方式一致，因此不再赘述。</span></p><p style=\"margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; font-family:Arial; font-size:14px; line-height:26px\"><span style=\"font-size: 14px;\">具体请参考：</span><a href=\"/blog/article/92.shtml\" target=\"_self\"><span style=\"font-size: 14px;\">Spring mvc使用XML配置文件方式实现简单HelloWorld</span></a></p></div>',0,'SpringMVC 注解 HelloWorld','实现Spring MVC有两种不同的方式：基于XML配置文件和基于注解。上篇博客介绍了基于XML配置文件的方式，这里我们使用基于注解的方式来实现。下面只重点介绍与XML配置文件方式不同的两个地方：Spring配置文件（springmvc-servlet.xml）和Controller类。其中，springmvc-servlet,xml文件内容：<?xml version=\"1.0\" encodin...',10,13,'20161123/1479914260827.jpg'),(92,'Spring MVC通过xml配置文件方式实现简单HelloWorld','2016-11-20 23:39:12','<p><span style=\"font-size: 14px;\">实现Spring MVC有两种不同的方式：基于XML配置文件和基于注解。</span></p><p><span style=\"font-size: 14px;\">这里，我们使用XML文件的方式来实现。</span></p><p><span style=\"font-size: 14px;\">首先，我们需要在Eclipse或者是MyEclipse中新建一个web项目，并将Spring MVC所需的的jar包拷贝到lib目录下，如下图所示的jar包：</span></p><p><span style=\"font-size: 14px;\"><img src=\"/ueditor/jsp/upload/image/20161120/1479656229468020421.png\" alt=\"\"/><br/></span></p><p><span style=\"font-size: 14px;\"><br/></span></p><p><span style=\"font-size: 14px;\">然后，需要在web.xml文件中配置DispatcherServlet。它是Spring MVC的核心，所有的页面请求都将经过它被分发到指定的Controller中去。</span></p><pre class=\"brush:xml;toolbar:false\">&lt;?xml&nbsp;version=&quot;1.0&quot;&nbsp;encoding=&quot;UTF-8&quot;?&gt;\r\n&lt;web-app&nbsp;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\r\n	xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;\r\n	xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee&nbsp;http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;\r\n	id=&quot;WebApp_ID&quot;&nbsp;version=&quot;3.1&quot;&gt;\r\n&nbsp;&nbsp;&lt;display-name&gt;springMVCHello&lt;/display-name&gt;\r\n&nbsp;&nbsp;&lt;welcome-file-list&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;\r\n&nbsp;&nbsp;&lt;/welcome-file-list&gt;\r\n&nbsp;&nbsp;&lt;servlet&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\r\n&nbsp;&nbsp;&lt;/servlet&gt;\r\n&nbsp;&nbsp;&lt;servlet-mapping&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;url-pattern&gt;*.do&lt;/url-pattern&gt;\r\n&nbsp;&nbsp;&lt;/servlet-mapping&gt;\r\n&lt;/web-app&gt;</pre><p><span style=\"font-size: 14px;\">添加springmvc-servlet,xml文件，内容如下：</span></p><pre class=\"brush:xml;toolbar:false\">&lt;?xml&nbsp;version=&quot;1.0&quot;&nbsp;encoding=&quot;UTF-8&quot;?&gt;\r\n&lt;beans&nbsp;xmlns=&quot;http://www.springframework.org/schema/beans&quot;\r\n	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\r\n	xmlns:p=&quot;http://www.springframework.org/schema/p&quot;\r\n	xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\r\n	xsi:schemaLocation=&quot;http://www.springframework.org/schema/mvc&nbsp;http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd\r\n		http://www.springframework.org/schema/beans&nbsp;http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\r\n		http://www.springframework.org/schema/context&nbsp;http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;\r\n	\r\n	&lt;!--&nbsp;配置HandlerMapping&nbsp;通过BeanName找到对应的Controller	--&gt;\r\n	&lt;bean&nbsp;class=&quot;org.springframework.web.servlet.mvc.support.ControllerBeanNameHandlerMapping&quot;&gt;&lt;/bean&gt;\r\n\r\n	&lt;!--&nbsp;配置Controller&nbsp;--&gt;\r\n	&lt;bean&nbsp;name=&quot;/hello.do&quot;&nbsp;class=&quot;com.xjc.controller.HelloController&quot;&gt;&lt;/bean&gt;\r\n	\r\n	&lt;!--&nbsp;配置视图解析器&nbsp;--&gt;\r\n	&lt;bean&nbsp;class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;\r\n		&lt;!--&nbsp;前缀&nbsp;--&gt;\r\n		&lt;property&nbsp;name=&quot;prefix&quot;&nbsp;value=&quot;/&quot;&gt;&lt;/property&gt;\r\n		&lt;!--&nbsp;后缀&nbsp;--&gt;\r\n		&lt;property&nbsp;name=&quot;suffix&quot;&nbsp;value=&quot;.jsp&quot;&gt;&lt;/property&gt;\r\n	&lt;/bean&gt;\r\n&lt;/beans&gt;</pre><p><span style=\"font-size: 14px;\">编写HelloController类（继承AbstractController类），内容如下：</span></p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.xjc.controller;\r\n\r\nimport&nbsp;javax.servlet.http.HttpServletRequest;\r\nimport&nbsp;javax.servlet.http.HttpServletResponse;\r\n\r\nimport&nbsp;org.springframework.web.servlet.ModelAndView;\r\nimport&nbsp;org.springframework.web.servlet.mvc.AbstractController;\r\n\r\npublic&nbsp;class&nbsp;HelloController&nbsp;extends&nbsp;AbstractController{\r\n\r\n	@Override\r\n	protected&nbsp;ModelAndView&nbsp;handleRequestInternal(HttpServletRequest&nbsp;request,\r\n			HttpServletResponse&nbsp;response)&nbsp;throws&nbsp;Exception&nbsp;{\r\n		String&nbsp;hello&nbsp;=&nbsp;request.getParameter(&quot;hello&quot;);\r\n		System.out.println(&quot;--------&nbsp;:&nbsp;&quot;+hello);\r\n		ModelAndView&nbsp;mav&nbsp;=&nbsp;new&nbsp;ModelAndView(&quot;index&quot;);\r\n		mav.addObject(&quot;helloworld&quot;,&quot;&nbsp;hello&nbsp;&quot;+&nbsp;hello);\r\n		return&nbsp;mav;\r\n	}\r\n}</pre><p><span style=\"font-size: 14px;\">编写hello.jsp页面：</span></p><pre class=\"brush:html;toolbar:false\">&lt;%@&nbsp;page&nbsp;language=&quot;java&quot;&nbsp;import=&quot;java.util.*&quot;&nbsp;contentType=&quot;text/html;charset=utf-8&quot;%&gt;\r\n&lt;html&gt;\r\n&nbsp;&nbsp;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;\r\n&nbsp;&nbsp;&lt;body&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;form&nbsp;action=&quot;hello.do&quot;&nbsp;method=&quot;post&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;	hello:&lt;input&nbsp;type=&quot;text&quot;&nbsp;name=&quot;hello&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;	&lt;input&nbsp;type=&quot;submit&quot;&nbsp;value=&quot;提交&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt;\r\n&nbsp;&nbsp;&lt;/body&gt;\r\n&lt;/html&gt;</pre><p><span style=\"font-size: 14px;\">编写index.jsp页面（返回结果的页面）：</span><br/></p><pre class=\"brush:html;toolbar:false\">&lt;%@&nbsp;page&nbsp;language=&quot;java&quot;&nbsp;import=&quot;java.util.*&quot;&nbsp;pageEncoding=&quot;utf-8&quot;%&gt;\r\n&lt;!DOCTYPE&nbsp;HTML&nbsp;PUBLIC&nbsp;&quot;-//W3C//DTD&nbsp;HTML&nbsp;4.01&nbsp;Transitional//EN&quot;&gt;\r\n&lt;html&gt;\r\n&nbsp;&nbsp;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;\r\n&nbsp;&nbsp;&lt;body&gt;\r\n&nbsp;&nbsp;&nbsp;&lt;h1&gt;${helloworld&nbsp;}&lt;/h1&gt;\r\n&nbsp;&nbsp;&lt;/body&gt;\r\n&lt;/html&gt;</pre><p><span style=\"font-size: 14px;\">运行效果：</span></p><p><img src=\"/ueditor/jsp/upload/image/20161120/1479656231280047022.png\" alt=\"\"/><br/></p><p><br/></p><p><img src=\"/ueditor/jsp/upload/image/20161120/1479656231374086823.png\" alt=\"\"/><br/></p><p><br/></p>',0,'SpringMVC XML文件 HelloWorld','实现Spring MVC有两种不同的方式：基于XML配置文件和基于注解。这里，我们使用XML文件的方式来实现。首先，我们需要在Eclipse或者是MyEclipse中新建一个web项目，并将Spring MVC所需的的jar包拷贝到lib目录下，如下图所示的jar包：然后，需要在web.xml文件中配置DispatcherServlet。它是Spring MVC的核心，所有的页面请求都将经过它被分...',7,13,'20161123/1479867137249.jpg'),(93,'ExtJs Treepanel 实现整个树形菜单刷新','2016-11-20 23:46:14','<p style=\"margin-top:5px; margin-bottom:5px; font-family:sans-serif; font-size:16px\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">在之前的一次项目开发学习过程中，我需要实现一个功能，就是点击导航栏的链接后左侧树形菜单自动生成对应的菜单项。当时这个问题困扰了我很长一段时间。</span></p><p style=\"margin-top:5px; margin-bottom:5px; font-family:sans-serif; font-size:16px\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">后来，在看了ExtJs官方的文档及Demo后一下恍然大悟。</span></p><p style=\"margin-top:5px; margin-bottom:5px; font-family:sans-serif; font-size:16px\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">我们来认真分析一下要实现这个功能就是让树形菜单整个刷新。</span></p><p style=\"margin-top:5px; margin-bottom:5px; font-family:sans-serif; font-size:16px\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">首先来看看官方的Demo里面是怎么写的：</span></p><p style=\"margin-top:5px; margin-bottom:5px; font-family:sans-serif; font-size:16px\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">后台Default.aspx.cs文件中的关键代码：</span></p><pre class=\"brush:c#;toolbar:false\">[DirectMethod]\r\n&nbsp;public&nbsp;string&nbsp;RefreshMenu()\r\n{\r\n&nbsp;&nbsp;&nbsp;&nbsp;Ext.Net.TreeNodeCollection&nbsp;nodes&nbsp;=&nbsp;this.BuildTree(null);\r\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;nodes.ToJson();\r\n&nbsp;}</pre><p style=\"margin-top:5px; margin-bottom:5px; font-family:sans-serif; font-size:16px\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">前台Default.aspx文件中的关键Javascript代码：</span></p><pre class=\"brush:js;toolbar:false\">&lt;script&nbsp;type=&quot;text/javascript&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;refreshTree&nbsp;=&nbsp;function&nbsp;(tree)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ext.net.DirectMethods.RefreshMenu({\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success&nbsp;:&nbsp;function&nbsp;(result)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;nodes&nbsp;=&nbsp;eval(result);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(nodes.length&nbsp;&gt;&nbsp;0){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tree.initChildren(nodes);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tree.getRootNode().removeChildren();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&lt;/script&gt;</pre><p style=\"margin-top:5px; margin-bottom:5px; font-family:sans-serif; font-size:16px\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">从上面的几行代码可以看出，使用tree.initChildren()方法就可以达到刷新整棵树的目的。</span></p><p style=\"margin-top:5px; margin-bottom:5px; font-family:sans-serif; font-size:16px\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">因此，我们来依着葫芦画瓢。</span></p><p style=\"margin-top:5px; margin-bottom:5px; font-family:sans-serif; font-size:16px\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">首先，后台Main.aspx.cs文件关键代码如下（这里省略了构建树形菜单的代码）：</span></p><pre class=\"brush:c#;toolbar:false\">[DirectMethod]\r\n&nbsp;public&nbsp;string&nbsp;RefreshMenu(string&nbsp;sid)\r\n{\r\n&nbsp;&nbsp;&nbsp;&nbsp;Ext.Net.TreeNodeCollection&nbsp;nodes&nbsp;=&nbsp;this.BuildTree(sid);\r\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;nodes.ToJson();\r\n&nbsp;}</pre><p style=\"margin-top:5px; margin-bottom:5px; font-family:sans-serif; font-size:16px\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">其次，前台Main.aspx文件中Javascript代码如下：</span></p><pre class=\"brush:js;toolbar:false\">$(document).ready(function&nbsp;()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//点击二级菜单项的事件\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$(&quot;ul#topnav&nbsp;li&nbsp;ul&nbsp;a&quot;).click(function&nbsp;()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;tree&nbsp;=&nbsp;Ext.getCmp(&quot;TreePanel1&quot;);&nbsp;//获取树形菜单组件\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;sid&nbsp;=&nbsp;$(this)[0].id;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;refreshTree(tree,&nbsp;sid);&nbsp;//刷新树形菜单\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//消除默认行为\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\r\n\r\n&nbsp;});\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;//刷新树形菜单\r\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;refreshTree&nbsp;=&nbsp;function&nbsp;(tree,&nbsp;sid)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ext.net.DirectMethods.RefreshMenu(sid,&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success:&nbsp;function&nbsp;(result)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;nodes&nbsp;=&nbsp;eval(result);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//alert(result);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(nodes.length&nbsp;&gt;&nbsp;0)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tree.initChildren(nodes);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Ext.Msg.alert(&#39;提示&#39;,&nbsp;&#39;成功&#39;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tree.getRootNode().removeChildren();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Ext.Msg.alert(&#39;警告&#39;,&nbsp;&#39;失败&#39;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\r\n&nbsp;&nbsp;&nbsp;&nbsp;}</pre><p style=\"margin-top:5px; margin-bottom:5px; font-family:sans-serif; font-size:16px\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">前台Main.aspx页面对应的html代码：</span></p><pre class=\"brush:html;toolbar:false\">&lt;ul&nbsp;id=&quot;topnav&quot;&nbsp;style=&quot;float:right;&nbsp;margin-right:90px;&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&nbsp;&nbsp;style=&quot;width:100px;&nbsp;text-align:center&quot;&gt;常用功能&lt;/li&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&nbsp;id=&quot;menu1&quot;&nbsp;onmouseover=&quot;&quot;&nbsp;&nbsp;style=&quot;width:100px;&nbsp;text-align:center&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;a&nbsp;href=&quot;#&quot;&gt;工单、绩效&lt;/a&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ul&nbsp;id=&quot;submenu1&quot;&nbsp;class=&quot;left_side&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;asp:Repeater&nbsp;runat=&quot;server&quot;&nbsp;ID=&quot;rp_gdjx&quot;&nbsp;DataSourceID=&quot;SqlDataSource1&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ItemTemplate&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;a&nbsp;id=&quot;&lt;%#Eval(&quot;GNDM&quot;)&nbsp;%&gt;&quot;&nbsp;href=&#39;&#39;&gt;&lt;%#Eval(&quot;GNMC&quot;)%&gt;&lt;/a&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ItemTemplate&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/asp:Repeater&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;asp:SqlDataSource&nbsp;ID=&quot;SqlDataSource1&quot;&nbsp;runat=&quot;server&quot;&nbsp;ConnectionString=&quot;&lt;%$&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConnectionStrings:YXGLXTConnectionString&nbsp;%&gt;&quot;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SelectCommand=&quot;select&nbsp;*&nbsp;from&nbsp;tblXTGN&nbsp;where&nbsp;GNDM&nbsp;in(01,02,03)&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/asp:SqlDataSource&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/li&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ul&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/li&gt;\r\n&nbsp;&lt;/ul&gt;</pre><p style=\"margin-top:5px; margin-bottom:5px; font-family:sans-serif; font-size:16px\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">最后实现的效果如图：</span></p><p style=\"margin-top:5px; margin-bottom:5px; font-family:sans-serif; font-size:16px\"><img src=\"/ueditor/jsp/upload/image/20161120/1479656532984073631.png\" alt=\"\"/></p><p style=\"margin-top:5px; margin-bottom:5px; font-family:sans-serif; font-size:16px\"><img src=\"/ueditor/jsp/upload/image/20161122/1479829911640032270.png\" alt=\"\"/></p><p style=\"margin-top:5px; margin-bottom:5px; font-family:sans-serif; font-size:16px\"><img src=\"/ueditor/jsp/upload/image/20161122/1479829913609058402.png\" alt=\"\"/><img src=\"/ueditor/jsp/upload/image/20161120/1479656533249061843.png\" alt=\"\"/><br/></p><div><br/></div><p><br/></p>',0,'ExtJs 树形菜单刷新','在之前的一次项目开发学习过程中，我需要实现一个功能，就是点击导航栏的链接后左侧树形菜单自动生成对应的菜单项。当时这个问题困扰了我很长一段时间。后来，在看了ExtJs官方的文档及Demo后一下恍然大悟。我们来认真分析一下要实现这个功能就是让树形菜单整个刷新。首先来看看官方的Demo里面是怎么写的：后台Default.aspx.cs文件中的关键代码：[DirectMethod] public stri...',19,27,'20161123/1479868521609.jpg'),(96,'本博客目前存在的BUG','2016-11-23 11:50:02','<p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\">项目目前存在以下几个较大的问题（BUG）：</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">1. 全文关键字检索报错，如下：</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><img src=\"/images/20161127/1480182482294022012.png\" title=\"1480182482294022012.png\" alt=\"BUG.png\" height=\"344\" width=\"722\"/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">2. 修改页面下拉框数据回显失败，类似以下情况：</span></p><pre class=\"brush:html;toolbar:false\">&lt;select&nbsp;class=&quot;select&quot;&nbsp;id=&quot;type&quot;&nbsp;name=&quot;typeId&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;option&nbsp;value=&quot;0&quot;&gt;--请选择--&lt;/option&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;c:forEach&nbsp;var=&quot;blogType&quot;&nbsp;items=&quot;${blogTypeList&nbsp;}&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;option&nbsp;value=&quot;${blogType.typeId&nbsp;}&quot;&nbsp;&lt;c:if&nbsp;test=&quot;${blogType.typeId&nbsp;==&nbsp;blog.typeId&nbsp;}&quot;&gt;selected=&quot;selected&quot;&lt;/c:if&gt;&gt;${blogType.typeName&nbsp;}&lt;/option&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/c:forEach&gt;\r\n&lt;/select&gt;</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">问题：以上思路是否正确？？？</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">3. 分页控制存在小问题：当按分类查询时显示分类之前的分页。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">4. 后台”回首页“链接不能在frame外打开网页。<br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">update：2016年11月23日 23:46:21</span></strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">分页问题已经解决。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">问题原因：之前获取的数据总条数是不带分类条件时的，而带条件时就需要重新获取带分类条件的数据总条数。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">解决办法：当带有条件时重新获取<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">带分类条件的数据总条数</span></span></p><pre class=\"brush:java;toolbar:false\">//获取不带条件时分页的数据总条数\r\nint&nbsp;totalCount&nbsp;=&nbsp;blogService.getBlogList(map).size();\r\npageBean.setTotalCount(totalCount);\r\nint&nbsp;pageSize&nbsp;=&nbsp;pageBean.getPageSize();\r\nmap.put(&quot;start&quot;,&nbsp;pageBean.getStart());\r\nmap.put(&quot;size&quot;,&nbsp;pageSize);\r\nmap.put(&quot;typeId&quot;,&nbsp;typeId);\r\nmap.put(&quot;releaseDate&quot;,&nbsp;releaseDate);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n//获取带有类别或日期分类条件时分页的数据总条数\r\nList&lt;Blog&gt;&nbsp;blogList&nbsp;=&nbsp;blogService.getBlogList(map);\r\nif(!StringUtil.isEmpty(typeId)&nbsp;||&nbsp;!StringUtil.isEmpty(releaseDate)){\r\n&nbsp;&nbsp;&nbsp;&nbsp;//实际博客数\r\n&nbsp;&nbsp;&nbsp;&nbsp;totalCount&nbsp;=&nbsp;blogList.size();\r\n}\r\n//以下是获取分页的代码</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">update：2016年11月26日 09:44:40</span></strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">下拉框数据回显问题已解决。<br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">问题原因：在修改页面中不能取得${blog.typeId}值</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">解决办法：</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在后台将blog的typeId值存在request域对象中：</span></p><pre class=\"brush:java;toolbar:false\">model.addAttribute(&quot;typeId&quot;,blog.getBlogType().getTypeId());</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在前台则通过${typeId}来获取值，如下：</span></p><pre class=\"brush:html;toolbar:false\">&lt;select&nbsp;class=&quot;select&quot;&nbsp;id=&quot;type&quot;&nbsp;name=&quot;typeId&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;option&nbsp;value=&quot;0&quot;&gt;--请选择--&lt;/option&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;c:forEach&nbsp;var=&quot;blogType&quot;&nbsp;items=&quot;${blogTypeList&nbsp;}&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;option&nbsp;value=&quot;${blogType.typeId&nbsp;}&quot;&nbsp;&lt;c:if&nbsp;test=&quot;${blogType.typeId&nbsp;==&nbsp;typeId&nbsp;}&quot;&gt;selected=&quot;selected&quot;&lt;/c:if&gt;&gt;${blogType.typeName&nbsp;}&lt;/option&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/c:forEach&gt;\r\n&lt;/select&gt;</pre><p><span style=\"color: rgb(255, 0, 0);\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">待解决问题：</span></strong><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span></strong></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">1. 全文关键字检索报错：NumberFormatException。</span></p><p><span style=\"color: rgb(255, 0, 0);\">2.<span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> 后台”回首页“链接不能在frame外打开网页。</span></span></p><p><span style=\"color: rgb(255, 0, 0);\"><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></span></p><p><span style=\"color: rgb(255, 0, 0);\"><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span></span></p><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">update：2016年11月28日 11:38:32</span></strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">问题已解决：后台”回首页“链接不能在frame外打开网页</span>。</p><pre class=\"brush:html;toolbar:false\">&lt;a&nbsp;href=&quot;javascript:void(0)&quot;&nbsp;onclick=&quot;window.parent.location.href=&#39;index.shtml&#39;&quot;&gt;回首页&lt;/a&gt;</pre><p><span style=\"color: rgb(255, 0, 0);\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">待解决问题：</span></strong><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span></strong></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">全文关键字检索报错：NumberFormatException。</span></p>',0,'BUG','项目目前存在以下几个较大的问题（BUG）：1. 全文关键字检索报错，如下：2. 修改页面下拉框数据回显失败，类似以下情况：<select class=\"select\" id=\"type\" name=\"typeId\">      <option value=\"0\">--请选择--</option>      <c:forEach var=\"blogType\" items=\"${blogTypeLis...',44,1,'20161123/1479914183749.jpg'),(97,'JVM组成及工作原理','2016-11-23 14:46:04','<p style=\"font-size: 14px;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">JVM是java的核心和基础，在java编译器和os平台之间的虚拟处理器。它是一种利用软件方法实现的抽象的计算机基于下层的操作系统和硬件平台，可以在上面执行java的字节码程序。</span></p><p style=\"font-size: 14px;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">java编译器只要面向JVM，生成JVM能理解的代码或字节码文件。Java源文件经编译成字节码程序，通过JVM将每一条指令翻译成不同平台机器码，通过特定平台运行。</span></p><p style=\"text-align: left; font-size: 14px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\">一、<span style=\"font-family: 微软雅黑,Microsoft YaHei;\">JVM执行程序的过程&nbsp;</span></span></strong></p><p style=\"font-size: 14px;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">I.加载.class文件</span></p><p style=\"font-size: 14px;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">II.管理并分配内存</span></p><p style=\"font-size: 14px;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">III.执行垃圾收集</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">JRE（java运行时环境）由JVM构造的java程序的运行环境</span></p><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\">二、JVM组成</span></strong></p><p><span style=\"font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">JVM的组成如图：</span></span></p><p><span style=\"font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><img src=\"/images/20161129/1480402628323043880.jpg\" title=\"1480402628323043880.jpg\" alt=\"JVM.jpg\" height=\"369\" width=\"559\"/></span></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>第一块：PC</strong><strong>寄存器</strong></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">PC<span style=\"font-size: 14px;\">寄存器是用于存储每个线程下一步将执行的</span>JVM<span style=\"font-size: 14px;\">指令，如该方法为</span>native<span style=\"font-size: 14px;\">的，则</span>PC<span style=\"font-size: 14px;\">寄存器中不存储任何信息。</span></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong><span style=\"font-size: 14px;\">第二块：</span>JVM</strong><strong><span style=\"font-size: 14px;\">栈</span></strong><strong><span style=\"font-size: 14px;\"></span></strong></span></p><p><strong><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">JVM<span style=\"font-size: 14px;\">栈是线程私有的</span></span></strong><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\">，每个线程创建的同时都会创建</span>JVM<span style=\"font-size: 14px;\">栈，</span>JVM<span style=\"font-size: 14px;\">栈中存放的为当前线程中局部基本类型的变量（</span>java<span style=\"font-size: 14px;\">中定义的八种基本类型：</span>boolean<span style=\"font-size: 14px;\">、</span>char<span style=\"font-size: 14px;\">、</span>byte<span style=\"font-size: 14px;\">、</span>short<span style=\"font-size: 14px;\">、</span>int<span style=\"font-size: 14px;\">、</span>long<span style=\"font-size: 14px;\">、</span>float<span style=\"font-size: 14px;\">、</span>double<span style=\"font-size: 14px;\">）、部分的返回结果以及</span>Stack Frame<span style=\"font-size: 14px;\">，非基本类型的对象在</span>JVM<span style=\"font-size: 14px;\">栈上仅存放一个指向堆上的地址</span></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong><span style=\"font-size: 14px; font-family: 宋体;\">第三块：堆（</span>Heap</strong><strong><span style=\"font-size: 14px; font-family: 宋体;\">）</span></strong><strong><span style=\"font-size: 14px; font-family: 宋体;\"></span></strong></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\">它</span><span style=\"font-size: 14px;\">是</span>JVM<span style=\"font-size: 14px;\">用来<strong>存储对象实例以及数组值</strong>的区域</span><span style=\"font-size: 14px;\">，可以认为</span>Java<span style=\"font-size: 14px;\">中所有通过</span>new<span style=\"font-size: 14px;\">创建的对象的内存都在此分配，</span>Heap<span style=\"font-size: 14px;\">中的对象的内存需要等待</span>GC<span style=\"font-size: 14px;\">进行回收。</span></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"line-height: normal; font-size: 9px;\"></span><span style=\"font-size: 14px;\">（1）堆是</span>JVM<span style=\"font-size: 14px;\">中所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也导致了</span>new<span style=\"font-size: 14px;\">对象的开销是比较大的。</span></span></span></span></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\">（2）<span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\">Sun Hotspot JVM<span style=\"font-size: 14px;\">为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间</span>TLAB<span style=\"font-size: 14px;\">（</span>Thread Local Allocati</span><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">on Buffer<span style=\"font-size: 14px;\">），其大小由</span>JVM<span style=\"font-size: 14px;\">根据运行的情况计算而得，在</span>TLAB<span style=\"font-size: 14px;\">上分配对象时不需要加锁，因此</span>JVM<span style=\"font-size: 14px;\">在给线程的对象分配内存时会尽量的在</span>TLAB<span style=\"font-size: 14px;\">上分配，在这种情况下</span>JVM<span style=\"font-size: 14px;\">中分配对象内存的性能和</span>C<span style=\"font-size: 14px;\">基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间</span></span><span style=\"font-size: 14px;\">分配。</span></span></span></span></span></span></span></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\">（3）<span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"line-height: normal; font-size: 9px;\"> </span>TLAB<span style=\"font-size: 14px;\">仅作用于新生代的</span>Eden Space<span style=\"font-size: 14px;\">，因此在编写</span>Java<span style=\"font-size: 14px;\">程序时，通常多个小的对象比大的对象分配起来更加高效。</span></span></span></span></span></span></span></span></span></span></p><p style=\"margin-left:48px;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"line-height: normal; font-size: 9px;\"> </span><span style=\"font-size: 14px;\"></span></span></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong><span style=\"font-size: 14px; font-family: 宋体;\">第四块：方法区域（</span>Method Area</strong><strong><span style=\"font-size: 14px; font-family: 宋体;\">）</span></strong><strong><span style=\"font-size: 14px; font-family: 宋体;\"></span></strong></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\">（</span>1<span style=\"font-size: 14px;\">）在</span>Sun JDK<span style=\"font-size: 14px;\">中这块区域对应的为</span>PermanetGeneration<span style=\"font-size: 14px;\">，又称为持久代。</span></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\">（</span>2<span style=\"font-size: 14px;\">）方法区域</span><strong><span style=\"font-size: 14px;\">存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为</span>final<span style=\"font-size: 14px;\">类型的常量、类中的</span>Field<span style=\"font-size: 14px;\">信息、类中的方法信息</span></strong><span style=\"font-size: 14px;\">，当开发人员在程序中通过</span>Class</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\">对象中的</span>getName<span style=\"font-size: 14px;\">、</span>isInterface<span style=\"font-size: 14px;\">等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被</span>GC<span style=\"font-size: 14px;\">，当方法区域需要使用的内存超过其允许的大小时，会抛出</span>OutOfMemory<span style=\"font-size: 14px;\">的错误信息。</span></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong><span style=\"font-size: 14px; font-family: 宋体;\">第五块：运行时常量池（</span>Runtime Constant Pool</strong><strong><span style=\"font-size: 14px; font-family: 宋体;\">）</span></strong><strong><span style=\"font-size: 14px; font-family: 宋体;\"></span></strong></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\">存放的为类中的固定的常量信息、方法和</span>Field<span style=\"font-size: 14px;\">的引用信息等，其空间从方法区域中分配。</span></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong><span style=\"font-size: 14px; font-family: 宋体;\">第六块：本地方法堆栈（</span>Native Method Stacks</strong><strong><span style=\"font-size: 14px; font-family: 宋体;\">）</span></strong><strong><span style=\"font-size: 14px; font-family: 宋体;\"></span></strong></span></p><p style=\"margin-left:28px;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">JVM<span style=\"font-size: 14px;\">采用本地方法堆栈来支持</span>native<span style=\"font-size: 14px;\">方法的执行，此区域用于</span><strong><span style=\"font-size: 14px;\">存储每个</span>native<span style=\"font-size: 14px;\">方法调用的状态</span></strong><span style=\"font-size: 14px;\">。</span><strong><span style=\"line-height: normal; font-size: 9px; font-weight: normal;\"><br/></span></strong></span></p><p><span style=\"font-size: 16px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>三、JVM垃圾回收</strong></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>GC</strong><strong>的基本原理：</strong>将内存中不再被使用的对象进行回收，GC中用于回收的方法称为收集器，由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\">（</span>1<span style=\"font-size: 14px;\">）对新生代的对象的收集称为</span>minor GC<span style=\"font-size: 14px;\">；</span></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\">（</span>2<span style=\"font-size: 14px;\">）对旧生代的对象的收集称为</span>Full GC<span style=\"font-size: 14px;\">；</span></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\">（</span>3<span style=\"font-size: 14px;\">）程序中主动调用</span>System.gc()<span style=\"font-size: 14px;\">强制执行的</span>GC<span style=\"font-size: 14px;\">为</span>Full GC<span style=\"font-size: 14px;\">。</span></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong><span style=\"font-size: 14px; font-family: 宋体;\">不同的对象引用类型，</span> GC</strong><strong><span style=\"font-size: 14px; font-family: 宋体;\">会采用不同的方法进行回收，</span>JVM</strong><strong><span style=\"font-size: 14px; font-family: 宋体;\">对象的引用分为了四种类型：</span></strong><strong><span style=\"font-size: 14px; font-family: 宋体;\"></span></strong></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\">（</span>1<span style=\"font-size: 14px;\">）强引用：默认情况下，对象采用的均为强引用（这个对象的实例没有其他对象引用，</span>GC<span style=\"font-size: 14px;\">时才会被回收）</span></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\">（</span>2<span style=\"font-size: 14px;\">）软引用：软引用是</span>Java<span style=\"font-size: 14px;\">中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被</span>GC<span style=\"font-size: 14px;\">）</span></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\">（</span>3<span style=\"font-size: 14px;\">）弱引用：在</span>GC<span style=\"font-size: 14px;\">时一定会被</span>GC<span style=\"font-size: 14px;\">回收</span></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px;\">（</span>4<span style=\"font-size: 14px;\">）虚引用：由于虚引用只是用来得知对象是否被</span>GC</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><br/><br/></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><br/></span></p>',0,'JVM 内存','JVM是java的核心和基础，在java编译器和os平台之间的虚拟处理器。它是一种利用软件方法实现的抽象的计算机基于下层的操作系统和硬件平台，可以在上面执行java的字节码程序。java编译器只要面向JVM，生成JVM能理解的代码或字节码文件。Java源文件经编译成字节码程序，通过JVM将每一条指令翻译成不同平台机器码，通过特定平台运行。一、JVM执行程序的过程 I.加载.class文件II.管理...',24,26,'20161123/1479884128718.jpg'),(98,'阿里druid数据库连接池配置详解','2016-11-25 13:45:51','<p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Druid是一个JDBC组件，它包括三部分：&nbsp;</span></strong></p><ul class=\" list-paddingleft-2\"><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">DruidDriver 代理Driver，能够提供基于Filter－Chain模式的插件体系。&nbsp;</span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">DruidDataSource 高效可管理的数据库连接池。&nbsp;</span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">SQLParser&nbsp;</span></p></li></ul><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Druid可以做什么？&nbsp;</span></strong></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">1) 可以监控数据库访问性能，Druid内置提供了一个功能强大的StatFilter插件，能够详细统计SQL的执行性能，这对于线上分析数据库访问性能有帮助。&nbsp;</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">2) 替换DBCP和C3P0。Druid提供了一个高效、功能强大、可扩展性好的数据库连接池。&nbsp;</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">3) 数据库密码加密。直接把数据库密码写在配置文件中，这是不好的行为，容易导致安全问题。DruidDruiver和DruidDataSource都支持PasswordCallback。&nbsp;</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">4) SQL执行日志，Druid提供了不同的LogFilter，能够支持Common-Logging、Log4j和JdkLog，你可以按需要选择相应的LogFilter，监控你应用的数据库访问情况。 <br/></span></p><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Druid中包含以下配置项：</span></strong><br/></p><table class=\"table table-bordered\" width=\"605\"><tbody><tr style=\"line-height:1.3em\" class=\"firstRow\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:0px; border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">配置</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:0px; border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">缺省值</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:0px; border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">说明</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">name</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><br/></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">配置这个属性的意义在于，如果存在多个数据源，监控的时候&nbsp;<br/>可以通过名字来区分开来。如果没有配置，将会生成一个名字，&nbsp;<br/>格式是：&quot;DataSource-&quot; + System.identityHashCode(this)</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">jdbcUrl</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><br/></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">连接数据库的url，不同数据库不一样。例如：&nbsp;<br/>mysql : jdbc:mysql://localhost:3306/user&nbsp; <br/>oracle : jdbc:oracle:thin:@localhost:1521:orcl</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">username</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><br/></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">连接数据库的用户名</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">password</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><br/></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">连接数据库的密码。</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">driverClassName</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">根据url自动识别</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">initialSize</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">0</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">maxActive</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">8</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">最大连接池数量</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">maxIdle</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">8</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">已经不再使用，配置了也没效果</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">minIdle</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><br/></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">最小连接池数量</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">maxWait</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><br/></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">获取连接时最大等待时间，单位毫秒。配置了maxWait之后，&nbsp;<br/>缺省启用公平锁，并发效率会有所下降，&nbsp;<br/>如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">poolPreparedStatements</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">false</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">是否缓存preparedStatement，也就是PSCache。&nbsp;<br/>PSCache对支持游标的数据库性能提升巨大，比如说oracle。&nbsp;<br/>在mysql5.5以下的版本中没有PSCache功能，建议关闭掉。<br/>作者在5.5版本中使用PSCache，通过监控界面发现PSCache有缓存命中率记录，&nbsp;<br/>该应该是支持PSCache。</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">maxOpenPreparedStatements</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">-1</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">要启用PSCache，必须配置大于0，当大于0时，&nbsp;<br/>poolPreparedStatements自动触发修改为true。&nbsp;<br/>在Druid中，不会存在Oracle下PSCache占用内存过多的问题，&nbsp;<br/>可以把这个数值配置大一些，比如说100</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">validationQuery</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><br/></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">用来检测连接是否有效的sql，要求是一个查询语句。&nbsp;<br/>如果validationQuery为null，testOnBorrow、testOnReturn、&nbsp;<br/>testWhileIdle都不会其作用。</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">testOnBorrow</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">true</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">testOnReturn</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">false</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">testWhileIdle</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">false</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">建议配置为true，不影响性能，并且保证安全性。&nbsp;<br/>申请连接的时候检测，如果空闲时间大于&nbsp;<br/>timeBetweenEvictionRunsMillis，&nbsp;<br/>执行validationQuery检测连接是否有效。</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">timeBetweenEvictionRunsMillis</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><br/></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">有两个含义：&nbsp;<br/>1) Destroy线程会检测连接的间隔时间&nbsp;<br/>2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">numTestsPerEvictionRun</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><br/></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">不再使用，一个DruidDataSource只支持一个EvictionRun</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">minEvictableIdleTimeMillis</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><br/></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><br/></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">connectionInitSqls</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><br/></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">物理连接初始化的时候执行的sql</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">exceptionSorter</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">根据dbType自动识别</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">当数据库抛出一些不可恢复的异常时，抛弃连接</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">filters</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><br/></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">属性类型是字符串，通过别名的方式配置扩展插件，&nbsp;<br/>常用的插件有：&nbsp;<br/>监控统计用的filter:stat&nbsp;&nbsp;<br/>日志用的filter:log4j&nbsp;<br/>防御sql注入的filter:wall</span></td></tr><tr style=\"line-height:1.3em\"><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">proxyFilters</span></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><br/></td><td style=\"padding:8px; line-height:1.3em; vertical-align:top; border-top-width:1px; border-top-style:solid; border-top-color:rgb(221,221,221); border-left-width:1px; border-left-style:solid; border-left-color:rgb(221,221,221); font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">类型是List&lt;com.alibaba.druid.filter.Filter&gt;，&nbsp;<br/>如果同时配置了filters和proxyFilters，&nbsp;<br/>是组合关系，并非替换关系</span></td></tr></tbody></table><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>Druid在Spring中的配置如下</strong>：</span></p><pre class=\"brush:xml;toolbar:false\">&nbsp;&lt;bean&nbsp;name=&quot;transactionManager&quot;&nbsp;class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&nbsp;&gt;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;dataSource&quot;&nbsp;ref=&quot;dataSource&quot;&gt;&lt;/property&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&nbsp;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean&nbsp;id=&quot;propertyConfigurer&quot;&nbsp;class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&nbsp;&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;locations&quot;&nbsp;value=&quot;classpath:db.properties&quot;/&gt;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;阿里&nbsp;druid&nbsp;数据库连接池&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;bean&nbsp;id=&quot;dataSource&quot;&nbsp;class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&nbsp;destroy-method&nbsp;=&nbsp;&quot;close&quot;&nbsp;&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;数据库基本信息配置&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;property&nbsp;name&nbsp;=&nbsp;&quot;url&quot;&nbsp;value&nbsp;=&nbsp;&quot;${url}&quot;&nbsp;/&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;property&nbsp;name&nbsp;=&nbsp;&quot;username&quot;&nbsp;value&nbsp;=&nbsp;&quot;${username}&quot;&nbsp;/&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;property&nbsp;name&nbsp;=&nbsp;&quot;password&quot;&nbsp;value&nbsp;=&nbsp;&quot;${password}&quot;&nbsp;/&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;property&nbsp;name&nbsp;=&nbsp;&quot;driverClassName&quot;&nbsp;value&nbsp;=&nbsp;&quot;${driverClassName}&quot;&nbsp;/&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;property&nbsp;name&nbsp;=&nbsp;&quot;filters&quot;&nbsp;value&nbsp;=&nbsp;&quot;${filters}&quot;&nbsp;/&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;最大并发连接数&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;property&nbsp;name&nbsp;=&nbsp;&quot;maxActive&quot;&nbsp;value&nbsp;=&nbsp;&quot;${maxActive}&quot;&nbsp;/&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;初始化连接数量&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;property&nbsp;name&nbsp;=&nbsp;&quot;initialSize&quot;&nbsp;value&nbsp;=&nbsp;&quot;${initialSize}&quot;&nbsp;/&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;配置获取连接等待超时的时间&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;property&nbsp;name&nbsp;=&nbsp;&quot;maxWait&quot;&nbsp;value&nbsp;=&nbsp;&quot;${maxWait}&quot;&nbsp;/&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;最小空闲连接数&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;property&nbsp;name&nbsp;=&nbsp;&quot;minIdle&quot;&nbsp;value&nbsp;=&nbsp;&quot;${minIdle}&quot;&nbsp;/&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;property&nbsp;name&nbsp;=&nbsp;&quot;timeBetweenEvictionRunsMillis&quot;&nbsp;value&nbsp;=&quot;${timeBetweenEvictionRunsMillis}&quot;&nbsp;/&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;配置一个连接在池中最小生存的时间，单位是毫秒&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;property&nbsp;name&nbsp;=&nbsp;&quot;minEvictableIdleTimeMillis&quot;&nbsp;value&nbsp;=&quot;${minEvictableIdleTimeMillis}&quot;&nbsp;/&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;property&nbsp;name&nbsp;=&nbsp;&quot;validationQuery&quot;&nbsp;value&nbsp;=&nbsp;&quot;${validationQuery}&quot;&nbsp;/&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;property&nbsp;name&nbsp;=&nbsp;&quot;testWhileIdle&quot;&nbsp;value&nbsp;=&nbsp;&quot;${testWhileIdle}&quot;&nbsp;/&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;property&nbsp;name&nbsp;=&nbsp;&quot;testOnBorrow&quot;&nbsp;value&nbsp;=&nbsp;&quot;${testOnBorrow}&quot;&nbsp;/&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;property&nbsp;name&nbsp;=&nbsp;&quot;testOnReturn&quot;&nbsp;value&nbsp;=&nbsp;&quot;${testOnReturn}&quot;&nbsp;/&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;property&nbsp;name&nbsp;=&nbsp;&quot;maxOpenPreparedStatements&quot;&nbsp;value&nbsp;=&quot;${maxOpenPreparedStatements}&quot;&nbsp;/&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;打开&nbsp;removeAbandoned&nbsp;功能&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;property&nbsp;name&nbsp;=&nbsp;&quot;removeAbandoned&quot;&nbsp;value&nbsp;=&nbsp;&quot;${removeAbandoned}&quot;&nbsp;/&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;1800&nbsp;秒，也就是&nbsp;30&nbsp;分钟&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;property&nbsp;name&nbsp;=&nbsp;&quot;removeAbandonedTimeout&quot;&nbsp;value&nbsp;=&quot;${removeAbandonedTimeout}&quot;&nbsp;/&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;关闭&nbsp;abanded&nbsp;连接时输出错误日志&nbsp;--&gt;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;property&nbsp;name&nbsp;=&nbsp;&quot;logAbandoned&quot;&nbsp;value&nbsp;=&nbsp;&quot;${logAbandoned}&quot;&nbsp;/&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/&nbsp;bean&nbsp;&gt;</pre><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">db.properties文件内容如下：</span></strong></p><pre class=\"brush:xml;toolbar:false\">url:jdbc:mysql://localhost:3306/myblog?Unicode=true&amp;amp;characterEncoding=utf8\r\ndriverClassName:com.mysql.jdbc.Driver\r\nusername:root\r\npassword:root\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\nfilters:stat\r\n&nbsp;&nbsp;&nbsp;\r\nmaxActive:20\r\ninitialSize:1\r\nmaxWait:60000\r\nminIdle:10\r\nmaxIdle:15\r\n&nbsp;&nbsp;&nbsp;\r\ntimeBetweenEvictionRunsMillis:60000\r\nminEvictableIdleTimeMillis:300000\r\n&nbsp;&nbsp;&nbsp;\r\nvalidationQuery:SELECT&nbsp;&#39;x&#39;\r\ntestWhileIdle:true\r\ntestOnBorrow:false\r\ntestOnReturn:false\r\n\r\nmaxOpenPreparedStatements:20\r\nremoveAbandoned:true\r\nremoveAbandonedTimeout:1800\r\nlogAbandoned:true</pre><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">然后在web.xml中配置druid监控</span></strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">：</span></p><pre class=\"brush:xml;toolbar:false\">&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;连接池&nbsp;启用Web监控统计功能&nbsp;start--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;filter&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;init-param&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;param-name&gt;exclusions&lt;/param-name&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;param-value&gt;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&lt;/param-value&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/init-param&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/filter&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;filter-mapping&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/filter-mapping&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;servlet&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/servlet&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;servlet-mapping&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/servlet-mapping&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;连接池&nbsp;启用Web监控统计功能&nbsp;&nbsp;&nbsp;end--&gt;</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">访问监控页面：&nbsp;http://localhost:8080/MyBlog/druid/index.html</span></p><p><br/></p>',3,'数据库连接池 druid','Druid是一个JDBC组件，它包括三部分： DruidDriver 代理Driver，能够提供基于Filter－Chain模式的插件体系。 DruidDataSource 高效可管理的数据库连接池。 SQLParser Druid可以做什么？ 1) 可以监控数据库访问性能，Druid内置提供了一个功能强大的StatFilter插件，能够详细统计SQL的执行性能，这对于线上分析数据库访问性能有帮助...',83,23,'20161125/1480052749999.jpg'),(100,'JDBC小结及Oracle数据库的安装步骤','2016-11-26 23:39:13','<div style=\"margin-top: 0px; margin-right: auto; margin-bottom: 0px; margin-left: auto; padding-top: 20px; padding-right: 20px; padding-bottom: 20px; padding-left: 20px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; font-family: &#39;Microsoft YaHei&#39;, Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 1.6; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); max-width: 960px; \"><h3 style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 18px; \"><span style=\"font-size: 14px;\">JDBC规范定义的接口</span></h3><ul style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 30px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px;\">Connection：数据库连接接口</span></p></li><li><p><span style=\"font-size: 14px;\">Statement：执行静态SQL语句</span></p></li><li><p><span style=\"font-size: 14px;\">PreparedStatement：执行预编译SQL语句</span></p></li><li><p><span style=\"font-size: 14px;\">CallableStatement：执行存储过程</span></p></li><li><p><span style=\"font-size: 14px;\">ResultSet：结果集接口</span></p></li><li><p><span style=\"font-size: 14px;\">DataSource：数据源接口</span></p></li></ul><h4 style=\"margin-top: 20px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 16px; \"><span style=\"font-size: 14px;\">JDBC的工具类</span></h4><p style=\"margin-top: 10px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-size: 14px;\">DriverManager：驱动管理</span></p><h4 style=\"margin-top: 20px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 16px; \"><span style=\"font-size: 14px;\">JDBC的实现</span></h4><ul style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 30px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px;\">JDBC的实现并不是由Sun公司提供，而是由各个数据库生产商实现。</span></p></li><li><p><span style=\"font-size: 14px;\">在连接数据库时，首先要获得相应数据库的驱动程序。</span></p></li><li><p><span style=\"font-size: 14px;\">数据库连接字符串包含以下几个部分：</span></p></li><ul style=\"list-style-type: square;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px;\">JDBC协议</span></p></li><li><p><span style=\"font-size: 14px;\">数据库协议（一般使用数据库类型名称）</span></p></li><li><p><span style=\"font-size: 14px;\">数据库服务器地址</span></p></li><li><p><span style=\"font-size: 14px;\">端口号</span></p></li><li><p><span style=\"font-size: 14px;\">数据库名称<br/>格式：jdbc:数据库类型://服务器:端口号/数据库名称</span></p></li></ul></ul><h4 style=\"margin-top: 20px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 16px; \"><span style=\"font-size: 14px;\">Oracle数据库的安装</span></h4><ol style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 30px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px;\">安装数据库软件（不带数据库）</span></p></li><li><p><span style=\"font-size: 14px;\">创建监听器</span></p></li><li><p><span style=\"font-size: 14px;\">添加数据库</span></p></li></ol><h4 style=\"margin-top: 20px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 16px; \"><span style=\"font-size: 14px;\">验证Oracle数据库是否可用</span></h4><ol style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 30px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px;\">查看系统中的服务</span></p></li><ol style=\"list-style-type: lower-alpha;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px;\">查看数据库示例服务是否启动</span></p></li><li><p><span style=\"font-size: 14px;\">查看数据库监听服务是否启动</span></p></li></ol><li><p><span style=\"font-size: 14px;\">进入控制台，输入sqlplus /nolog命令</span></p></li><li><p><span style=\"font-size: 14px;\">连接数据库：conn scott/tiger@localhost:1522/ORCL<br/></span><img src=\"error.png\" alt=\"\"/></p><blockquote style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-size: 14px;\">如果失败，说：“无监听程序”，实际上是有的。这时就打开Net Manager工具进行配置</span></p></blockquote></li><li><p><span style=\"font-size: 14px;\">重启Oracle数据库实例和监听器服务</span></p></li><li><p><span style=\"font-size: 14px;\">启动SQL developer时需要选择jdk安装目录</span></p></li></ol><h4 style=\"margin-top: 20px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 16px; \"><span style=\"font-size: 14px;\">Oracle中使用序列来设置自动增长主键</span></h4><blockquote style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 0px !important; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-size: 14px;\">创建序列<br/>create sequence 序列名<br/>start with 1<br/>increment by 1<br/>nocache<br/>nocycle;</span></p></blockquote></div><p><br/></p>',0,'数据库','JDBC规范定义的接口Connection：数据库连接接口Statement：执行静态SQL语句PreparedStatement：执行预编译SQL语句CallableStatement：执行存储过程ResultSet：结果集接口DataSource：数据源接口JDBC的工具类DriverManager：驱动管理JDBC的实现JDBC的实现并不是由Sun公司提供，而是由各个数据库生产商实现。在连接...',6,23,'20161126/1480174752825.jpg'),(101,'JavaScript中的变量及对象','2016-11-26 23:47:20','<h4 style=\"margin-top: 20px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 16px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">JavaScript中变量的声明</span></h4><ul style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 30px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \" class=\" list-paddingleft-2\"><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">显式申明</span></p><blockquote style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">var i = 100; //显式申明</span></p></blockquote></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">隐式申明</span></p><blockquote style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">i = 100; //隐式申明</span></p></blockquote></li></ul><h4 style=\"margin-top: 20px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 16px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">JavaScript中变量的作用域</span></h4><ul style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 30px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \" class=\" list-paddingleft-2\"><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">全局变量 （在整个文档中都能访问）</span></p><blockquote style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在函数中不用var关键字声明，直接赋值</span></p></blockquote></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">局部变量（一般定义在函数中，只能在函数内部被访问）</span></p><blockquote style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在函数中用var关键字显示声明</span></p></blockquote></li></ul><h4 style=\"margin-top: 20px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 16px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">JS中的函数提升和变量提升</span></h4><ul style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 30px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \" class=\" list-paddingleft-2\"><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">？</strong>函数提升</span></p><blockquote style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在JavaScript中，函数的声明会自动提升到作用域顶部<strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">？</strong></span></p><pre style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 10px; padding-bottom: 6px; padding-left: 10px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-size: 13px; font-family: Consolas, &#39;Liberation Mono&#39;, Courier, monospace; background-color: rgb(248, 248, 248); border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); line-height: 19px; overflow-x: auto; overflow-y: auto; border-top-left-radius: 3px 3px; border-top-right-radius: 3px 3px; border-bottom-right-radius: 3px 3px; border-bottom-left-radius: 3px 3px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">foo()<br/>function foo(){}<br/>和<br/>foo()<br/>var foo=function(){}<br/>的区别<br/></span></pre></blockquote></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">变量提升</span></p><blockquote style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在JavaScript中，变量的声明也会自动提升到作用域顶部</span></p><pre style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 10px; padding-bottom: 6px; padding-left: 10px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-size: 13px; font-family: Consolas, &#39;Liberation Mono&#39;, Courier, monospace; background-color: rgb(248, 248, 248); border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); line-height: 19px; overflow-x: auto; overflow-y: auto; border-top-left-radius: 3px 3px; border-top-right-radius: 3px 3px; border-bottom-right-radius: 3px 3px; border-bottom-left-radius: 3px 3px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> &nbsp;alert(a);<br/> &nbsp;var a = 2; //结果为undefined<br/></span></pre></blockquote></li></ul><h4 style=\"margin-top: 20px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 16px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">JavaScript对象</span></h4><p style=\"margin-top: 10px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">对象中可以包含属性，方法和子对象（子属性）</span></p><pre style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 6px; padding-right: 10px; padding-bottom: 6px; padding-left: 10px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-size: 13px; font-family: Consolas, &#39;Liberation Mono&#39;, Courier, monospace; background-color: rgb(248, 248, 248); border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); line-height: 19px; overflow-x: auto; overflow-y: auto; border-top-left-radius: 3px 3px; border-top-right-radius: 3px 3px; border-bottom-right-radius: 3px 3px; border-bottom-left-radius: 3px 3px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">var person={<br/> &nbsp; &nbsp;name:&#39;张三&#39;,<br/> &nbsp; &nbsp;eat:function(){},<br/> &nbsp; &nbsp;eyes:{<br/> &nbsp; &nbsp; &nbsp; &nbsp;name:&#39;眼睛&#39;,<br/> &nbsp; &nbsp; &nbsp; &nbsp;scroll:function(){}<br/> &nbsp; &nbsp;}<br/>}<br/></span></pre><blockquote style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">引入对象主要是用来组织代码，对数据进行封装</span></p></blockquote>',0,'JavaScript 变量 对象','JavaScript中变量的声明显式申明var i = 100; //显式申明隐式申明i = 100; //隐式申明JavaScript中变量的作用域全局变量 （在整个文档中都能访问）在函数中不用var关键字声明，直接赋值局部变量（一般定义在函数中，只能在函数内部被访问）在函数中用var关键字显示声明JS中的函数提升和变量提升？函数提升在JavaScript中，函数的声明会自动提升到作用域顶部？f...',2,12,'20161126/1480175240497.jpg'),(102,'JavaScript中常用的内置对象','2016-11-26 23:49:41','<h3 style=\"margin-top: 20px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 18px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">JavaScript内置对象</span></h3><ul style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 30px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \" class=\" list-paddingleft-2\"><li><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">Window对象</strong></span></p><blockquote style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">处于对象层次的最顶端，它提供了处理Navigator窗口的方法和属性。</span></p></blockquote><p style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">open()方法：</span></p><pre style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 6px; padding-right: 10px; padding-bottom: 6px; padding-left: 10px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-size: 13px; font-family: Consolas, &#39;Liberation Mono&#39;, Courier, monospace; background-color: rgb(248, 248, 248); border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); line-height: 19px; overflow-x: auto; overflow-y: auto; border-top-left-radius: 3px 3px; border-top-right-radius: 3px 3px; border-bottom-right-radius: 3px 3px; border-bottom-left-radius: 3px 3px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> &nbsp;//创建子窗口对象<br/> &nbsp;var newWin = window.open(&#39;sonWindow.html&#39;,&#39;mdzz&#39;,&#39;width=400,height=300&#39;);<br/> &nbsp;//改变子窗口内容<br/> &nbsp;newWin.document.getElementById(&#39;son&#39;).innerHTML = &#39;Hello , My son&#39;;<br/><br/> &nbsp;//获取父窗口对象<br/> &nbsp;var parentWin = window.opener;<br/> &nbsp;//改变父窗口内容<br/> &nbsp;parentWin.document.getElementById(&#39;parent&#39;).innerHTML = &#39;Hi , Dad&#39;;<br/></span></pre></li><li><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">位置对象(Location)</strong><br/>Location对象提供了与当前打开的URL一起工作的方法和属性，它是一个静态的对象。</span></p><blockquote style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">属性：</span></p><pre style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 6px; padding-right: 10px; padding-bottom: 6px; padding-left: 10px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-size: 13px; font-family: Consolas, &#39;Liberation Mono&#39;, Courier, monospace; background-color: rgb(248, 248, 248); border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); line-height: 19px; overflow-x: auto; overflow-y: auto; border-top-left-radius: 3px 3px; border-top-right-radius: 3px 3px; border-bottom-right-radius: 3px 3px; border-bottom-left-radius: 3px 3px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> &nbsp;hash 锚点名称 <br/> &nbsp;host 主机名称 <br/> &nbsp;hostname host:port <br/> &nbsp;href 完整的URL字符串 <br/> &nbsp;pathname 路径 <br/> &nbsp;port 端口 <br/> &nbsp;protocol 协议 <br/> &nbsp;search 查询信息<br/></span></pre><p style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">方法：</span></p><pre style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 10px; padding-bottom: 6px; padding-left: 10px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-size: 13px; font-family: Consolas, &#39;Liberation Mono&#39;, Courier, monospace; background-color: rgb(248, 248, 248); border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); line-height: 19px; overflow-x: auto; overflow-y: auto; border-top-left-radius: 3px 3px; border-top-right-radius: 3px 3px; border-bottom-right-radius: 3px 3px; border-bottom-left-radius: 3px 3px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> &nbsp;reload(): 重新加载 <br/> &nbsp;replace(): 用指定的网页取代当前网页，并且当按下浏览器的“后退”键时将不能返回原先的网页<br/></span></pre></blockquote></li><li><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">历史对象(History)</strong><br/>History对象提供了与历史清单有关的信息。</span></p><blockquote style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">方法：</span></p><pre style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 10px; padding-bottom: 6px; padding-left: 10px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-size: 13px; font-family: Consolas, &#39;Liberation Mono&#39;, Courier, monospace; background-color: rgb(248, 248, 248); border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); line-height: 19px; overflow-x: auto; overflow-y: auto; border-top-left-radius: 3px 3px; border-top-right-radius: 3px 3px; border-bottom-right-radius: 3px 3px; border-bottom-left-radius: 3px 3px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> &nbsp;back()：回到上一个历史记录中的网址。（和按下“后退”键等效） <br/> &nbsp;forward()： 回到下一个历史记录中的网址 。（和按下“前进”键等效）<br/> &nbsp;go(整数或URL)： 前往历史记录中的网址。<br/> &nbsp;（如果整数x&gt;0，则前进x个地 址，如果整数x&lt;0，则后退x个地址，如果x=0，则刷新当前页面）<br/></span></pre></blockquote></li><li><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">文档对象(Document)</strong><br/>document对象包含了与文档元素(elements)一起工作的对象，它将这些元素封装起来供编程人员使用。</span></p><h6 style=\"margin-top: 20px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; font-weight: bold; -webkit-font-smoothing: antialiased; color: rgb(119, 119, 119); font-size: 14px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><em style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">DOM操作</em></span></h6></li><ul style=\"list-style-type: square;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">创建节点：<strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">createElement</strong>(tagName)，createTextNode(data)方法</span></p><blockquote style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">如document.createElement(&#39;div&#39;)；<br/>document.createTextNode(&#39;这是一个文本节点&#39;)；</span></p></blockquote></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">添加节点</strong>：<strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">appendChild</strong>(newChild)方法</span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">插入节点</strong>：<strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">insertBefore</strong>(newChild, refChild)方法，<strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">它是body的方法</strong>。</span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">替换节点</strong>：<strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">replaceChild</strong>(newChild，oldChild)方法</span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">删除节点</strong>：<strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">removeChild</strong>(oldChild)方法</span></p></li></ul><li><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">浏览器对象（Navigator）</strong></span></p><blockquote style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">属性：<br/><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">appCodeName</strong>：返回浏览器的代码名，IE返回Mozilla<br/><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">appName</strong>：返回浏览器名，IE返回“Microsoft Internet Explorer”<br/><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">appVersion</strong>：返回浏览器版本，包括版本号、语言、操作平台等<br/><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">language</strong>：返回浏览器编译语言<br/><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">platform</strong>：返回操作平台</span></p></blockquote><pre style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 6px; padding-right: 10px; padding-bottom: 6px; padding-left: 10px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-size: 13px; font-family: Consolas, &#39;Liberation Mono&#39;, Courier, monospace; background-color: rgb(248, 248, 248); border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); line-height: 19px; overflow-x: auto; overflow-y: auto; border-top-left-radius: 3px 3px; border-top-right-radius: 3px 3px; border-bottom-right-radius: 3px 3px; border-bottom-left-radius: 3px 3px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> &nbsp;document.write(&#39;浏览器名：&#39;+navigator.appName+&#39;&lt;br&gt;&#39;);<br/> &nbsp;document.write(&#39;浏览器版本：&#39;+navigator.appVersion+&#39;&lt;br&gt;&#39;);<br/> &nbsp;document.write(&#39;浏览器代码名：&#39;+navigator.appCodeName+&#39;&lt;br&gt;&#39;);<br/> &nbsp;document.write(&#39;语言：&#39;+navigator.language+&#39;&lt;br&gt;&#39;);<br/> &nbsp;document.write(&quot;平台：&quot;+navigator.platform);<br/></span></pre></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">屏幕对象(Screen)</strong></span></p><blockquote style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">描述屏幕的显示及颜色属性。<br/><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">availHeight</strong>： 屏幕区域的可用高度<br/><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">availWidth</strong>&nbsp;：屏幕区域的可用宽度<br/><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">colorDepth</strong>&nbsp;：颜色深度 256/8 16/16 32M/32<br/><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">height</strong>&nbsp;：屏幕区域的实际高度<br/><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">width</strong>&nbsp;：屏幕区域的实际宽度</span></p></blockquote></li></ul><h3 style=\"margin-top: 20px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 18px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">常用处理事件</span></h3><ul style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 0px !important; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 30px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \" class=\" list-paddingleft-2\"><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">onfocus</strong>：聚焦时触发的事件</span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">onblur</strong>：失去焦点时触发的事件</span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">onsubmit</strong>：提交表单时触发的事件</span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">window.onload</strong>: 窗口加载完毕时触发的事件</span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">onmouseover</strong>：鼠标经过时触发的事件</span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">onmouseout</strong>：鼠标移除时触发的时间</span></p></li></ul><p><br/></p>',0,'JavaScript 内置对象','JavaScript内置对象Window对象处于对象层次的最顶端，它提供了处理Navigator窗口的方法和属性。open()方法：  //创建子窗口对象  var newWin = window.open(\'sonWindow.html\',\'mdzz\',\'width=400,height=300\');  //改变子窗口内容  newWin.document.getElementById(\'son...',2,12,'20161126/1480175381309.jpg'),(103,'Java中的数据类型和访问控制符','2016-11-26 23:56:03','<h4 style=\"margin-top: 20px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 16px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Java基本数据类型</span></h4><table><thead style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><tr style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 1px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); \" class=\"firstRow\"><th style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-weight: bold; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">基本类型</span></th><th style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-weight: bold; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">长度</span></th><th style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-weight: bold; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">最小值</span></th><th style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-weight: bold; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">最大值</span></th></tr></thead><tbody style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><tr style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 1px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); \"><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">byte</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">8-bit</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">-128</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">+127</span></td></tr><tr style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 1px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); \"><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">short</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">16-bit</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">-2^15</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">+2^15-1</span></td></tr><tr style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 1px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); \"><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">int</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">32-bit</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">-2^31</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">+2^31-1</span></td></tr><tr style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 1px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); \"><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">long</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">64-bit</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">-2^63</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">+2^63-1</span></td></tr><tr style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 1px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); \"><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">float</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">32-bit</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">3.402823e+38</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">1.401298e-45</span></td></tr><tr style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 1px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); \"><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">double</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">64-bit</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">1.797693e+308</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: center; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">4.9000000e-324</span></td></tr></tbody></table><p style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">注：e+38是乘以10的38次方，e-45是乘以10的负45次方</span></p><blockquote style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">另外，还有boolean：布尔型，取值ture或false</span></p></blockquote><h4 style=\"margin-top: 20px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 16px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">移位运算</span></h4><ul style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 30px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \" class=\" list-paddingleft-2\"><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&lt;&lt;：左移操作 （向左移动几位就乘以2的几次方）<br/></span><code style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-size: 12px; font-family: Consolas, &#39;Liberation Mono&#39;, Courier, monospace; white-space: nowrap; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(234, 234, 234); border-right-color: rgb(234, 234, 234); border-bottom-color: rgb(234, 234, 234); border-left-color: rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-top-left-radius: 3px 3px; border-top-right-radius: 3px 3px; border-bottom-right-radius: 3px 3px; border-bottom-left-radius: 3px 3px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">int a = 12 &lt;&lt; 2; //相当于12*2^2，结果为48</span></code></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&gt;&gt;：右移操作（向右移动几位就除以2的几次方）<br/></span><code style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-size: 12px; font-family: Consolas, &#39;Liberation Mono&#39;, Courier, monospace; white-space: nowrap; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(234, 234, 234); border-right-color: rgb(234, 234, 234); border-bottom-color: rgb(234, 234, 234); border-left-color: rgb(234, 234, 234); background-color: rgb(248, 248, 248); border-top-left-radius: 3px 3px; border-top-right-radius: 3px 3px; border-bottom-right-radius: 3px 3px; border-bottom-left-radius: 3px 3px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">int a = 12 &gt;&gt; 2; //相当于12÷(2^2)，结果为3</span></code></p></li></ul><h4 style=\"margin-top: 20px; margin-right: 0px; margin-bottom: 10px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; font-weight: bold; -webkit-font-smoothing: antialiased; font-size: 16px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Java中的访问控制与修饰符</span></h4><ul style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 0px !important; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 30px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \" class=\" list-paddingleft-2\"><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">private</span></p><blockquote style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">如果一个成员方法或成员变量名前使用了private访问控制符，那么这个成员只能在这个类的内部使用。</span></p></blockquote></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">默认访问控制符</span></p><blockquote style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">默认的访问控制成员可以被这个包中的其它类访问。如果一个子类与其父类位于不同的包中，子类也不能访问父类中的默认访问控制成员。</span></p></blockquote></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">protected</span></p><blockquote style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">如果一个成员方法或成员变量名前使用了protected访问控制符，那么这个成员既可以被同一个包中的其它类访问，也可以被不同包中的子类访问。</span></p></blockquote></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">public</span></p><blockquote style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">如果一个成员方法或成员变量名前使用了public访问控制符，那么这个成员可以被所有的类访问，不管访问类与被访问类是否在同一个包中。</span></p></blockquote></li></ul><p><br/></p>',0,'Java 数据类型 访问控制符','Java基本数据类型基本类型长度最小值最大值byte8-bit-128+127short16-bit-2^15+2^15-1int32-bit-2^31+2^31-1long64-bit-2^63+2^63-1float32-bit3.402823e+381.401298e-45double64-bit1.797693e+3084.9000000e-324注：e+38是乘以10的38次方，e-45...',6,10,'20161126/1480175763497.jpg'),(104,'Java面向对象基础知识','2016-11-26 23:57:28','<p><strong><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">Java面向对象基础知识</span></strong></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(128, 128, 128);\">1.&nbsp;</span>构造方法。与类同名，没有返回值。分默认构造方法和带参数的构造方法。构造方法可在子类中通过super关键字 调用父类的构造方法。<br/><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(128, 128, 128);\">2.&nbsp;</span>this关键字，可以通过this关键字来明确的引用类实例中的属性，与局部变量进行区分。<br/><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(128, 128, 128);\">3.&nbsp;</span>访问修饰符：private、protected、public、默认。<br/><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(128, 128, 128);\">4.&nbsp;</span>static描述符。静态方法。一般约定使用类名称进行调用。可以调用其它静态方法，只能访问静态数据，不能使 用this或super关键字。类的静态属性，则表达了一个类“全局”的属性。<br/><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(128, 128, 128);\">5.&nbsp;</span>final 可以用来定义“常量”，可以定义不能被子类重写方法<br/><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(128, 128, 128);\">6.&nbsp;</span>abstract抽象方法。必须声明在抽象类中。<br/><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(128, 128, 128);\">7.&nbsp;</span>方法重载，名称相同，参数不同。<br/><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(128, 128, 128);\">8.&nbsp;</span>方法重写。子类中具有与父类相同签名的方法，在子类的方法中可以用super.方法名称调用父类的方法。<br/><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(128, 128, 128);\">9.&nbsp;</span>继承<br/><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(128, 128, 128);\">10.&nbsp;</span>多态。<br/><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(128, 128, 128);\">11.&nbsp;</span>接口。interface。可以实现多重继承，这个与抽象类不同。类通过关键字implements实现接口，不同的接口有 逗号‘，’分隔。</span></p>',0,'Java 面向对象','Java面向对象基础知识1. 构造方法。与类同名，没有返回值。分默认构造方法和带参数的构造方法。构造方法可在子类中通过super关键字 调用父类的构造方法。2. this关键字，可以通过this关键字来明确的引用类实例中的属性，与局部变量进行区分。3. 访问修饰符：private、protected、public、默认。4. static描述符。静态方法。一般约定使用类名称进行调用。可以调用其它静...',4,10,'20161126/1480175848669.jpg'),(105,'cmd常用命令','2016-11-27 12:59:46','<p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">1. 显示占用端口的进程：<br/></span></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">netstat&nbsp;&nbsp; -ano|findstr&nbsp; 8080 （<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">查看占用8080端口的进程</span></span>）</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">2. taskkill命令，将上面显示的进程号，结束掉。</span></span><br/></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">taskkill&nbsp; /pid&nbsp; 6856&nbsp; /f</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">3. tasklist命令，列出计算机当前的所有任务</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">4. taskkill /f /im 【任务名】</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">如：<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">taskkill /f /im</span> eclipse.exe（强制结束ecclipse.exe任务）<br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p>',0,'cmd 命令','1. 显示占用端口的进程：netstat   -ano|findstr  8080 （查看占用8080端口的进程）2. taskkill命令，将上面显示的进程号，结束掉。taskkill  /pid  6856  /f3. tasklist命令，列出计算机当前的所有任务4. taskkill /f /im 【任务名】如：taskkill /f /im eclipse.exe（强制结束ecclips...',17,30,'20161127/1480179586715.jpg'),(106,'Android部分基础知识','2016-11-27 13:02:41','<p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Android中dimen(尺寸资源文件):长宽高用dp,文字用sp单位<br/><br/><strong>Android中Activity的使用：</strong><br/><br/>1.建立Activity类及定义属性和内部方法<br/>2.注册Activity -&gt; Manifest.xml<br/>3.在启动方法onCreate()中实现业务（重载Activity类的方法）<br/>&nbsp; 3.1&nbsp; 界面的定义 layout<br/>&nbsp; 3.2&nbsp; 界面的绑定 setContentView()<br/><br/><strong>结论：</strong><br/>1、Activity构造的时候 调用了attach，绑定了一个window<br/>2、Activity setContentView()，实际上是调用了window.setContentView()<br/><br/><strong>设置控件事件监听：</strong><br/><br/>1、事件主题，发生对象<br/>2、事件监听函数设置<br/>3、事件逻辑代码<br/><br/>事件：人物，地点，时间<br/><br/><strong>Android数据存储之SharedPreference（XML文件存储）</strong><br/><br/>1、通过getSharedPreference()方法得到一个SharedPreference对象<br/>2、通过edit()方法进行编辑 get SharedPreference.Editor<br/>3、最后通过commit()方法提交 Editor.commit()</span></p>',0,'Android 基础','Android中dimen(尺寸资源文件):长宽高用dp,文字用sp单位Android中Activity的使用：1.建立Activity类及定义属性和内部方法2.注册Activity -> Manifest.xml3.在启动方法onCreate()中实现业务（重载Activity类的方法）  3.1  界面的定义 layout  3.2  界面的绑定 setContentView()结论：1、Ac...',13,28,'20161127/1480179761731.png'),(107,'C#基础及数据库操作步骤','2016-11-27 11:33:56','<p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>数据类型的转换</strong>：</span></p><pre class=\"brush:c#;toolbar:false\">&nbsp;int&nbsp;a=int.Parse(str);&nbsp;//把字符串转换为整型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n\r\n&nbsp;int&nbsp;a=Convert.ToInt32(str);&nbsp;//把字符串转换为整型&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;\r\n&nbsp;string&nbsp;myStr=a.ToString();&nbsp;//把整型a转换回字符串类型</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>输入输出：</strong></span></p><pre class=\"brush:c#;toolbar:false\">&nbsp;Console.ReadLine();&nbsp;&nbsp;//输入一行\r\n&nbsp;Console.WriteLine();&nbsp;//输出一行\r\n&nbsp;\r\n&nbsp;//遍历输出数组\r\n&nbsp;int&nbsp;[]a={1,2,3,4,5};\r\n&nbsp;for(int&nbsp;i=0;i&lt;a.Length;i++)\r\n&nbsp;{\r\n&nbsp;&nbsp;&nbsp;Console.WriteLine(a[i]);\r\n&nbsp;}</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">或者</span></p><pre class=\"brush:c#;toolbar:false\">foreach(int&nbsp;m&nbsp;in&nbsp;a)//m是集合(数组)中的元素，a表示集合(数组)\r\n{\r\n&nbsp;&nbsp;Console.WriteLine(m);//输出结果\r\n}</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong><br/></strong></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>代码中实现对数据库的操作步骤：</strong><br/><br/>&nbsp; 1. 定义数据库的连接串（读取配置文件的连接串strConn）</span></p><pre class=\"brush:c#;toolbar:false\">string&nbsp;strConn=ConfigurationManager.AppSettings[&quot;ConnStr&quot;].ToString();</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; 2. 创建连接对象并打开数据库</span><br/></p><pre class=\"brush:c#;toolbar:false\">SqlConnection&nbsp;conn=new&nbsp;SqlConnection(strConn);\r\nconn.Open();</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; 3. 定义SQL语句（添加、修改、删除等操作），如下：</span></p><pre class=\"brush:c#;toolbar:false\">string&nbsp;sSql=&quot;select&nbsp;*&nbsp;from&nbsp;stu&quot;;</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; 4. 定义命令对象</span><br/></p><pre class=\"brush:c#;toolbar:false\">SqlCommand&nbsp;comm=new&nbsp;SqlCommand(sSql&nbsp;,conn);</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; 5. 执行SQL语句</span></p><pre class=\"brush:c#;toolbar:false\">comm.ExecuteNonQuery();//执行增删改语句\r\nSqlDataAdapter(sql,conn);</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; 6. 关闭数据库连接</span></p><pre class=\"brush:c#;toolbar:false\">conn.Close();</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>配置文件配置数据库连接字符串：</strong></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> 在配置文件中用connectionStrings或appSettings两种方式，并在C#程序代码中读入</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">1. 在web.config文件中进行如下配置：</span></p><pre class=\"brush:xml;toolbar:false\">&lt;configuration&gt;\r\n\r\n&nbsp;&nbsp;&lt;appSettings&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;add&nbsp;key=&quot;AccessConnectionString&quot;&nbsp;value=&quot;Provider=Microsoft.Jet.OLEDB.4.0;Data&nbsp;Source=|DataDirectory|\\GSWZ.mdb&quot;/&gt;\r\n&nbsp;&nbsp;&lt;/appSettings&gt;\r\n&nbsp;&nbsp;\r\n&nbsp;&nbsp;&lt;connectionStrings&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;add&nbsp;name=&quot;ConnectionString&quot;&nbsp;connectionString=&quot;Provider=Microsoft.Jet.OLEDB.4.0;Data&nbsp;Source=|DataDirectory|\\GSWZ.mdb;Persist&nbsp;Security&nbsp;Info=True&quot;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;providerName=&quot;System.Data.OleDb&quot;&nbsp;/&gt;\r\n&nbsp;&nbsp;&lt;/connectionStrings&gt;\r\n&nbsp;&nbsp;\r\n&lt;/configuration&gt;</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">2. 在代码中如下引入：</span></p><pre class=\"brush:c#;toolbar:false\">//通过appSettings节点配置\r\nstring&nbsp;strConn&nbsp;=&nbsp;ConfigurationManager.AppSettings[&quot;ConnStr&quot;].ToString();\r\n\r\n//通过connectionStrings节点配置\r\nstring&nbsp;strConn&nbsp;=&nbsp;ConfigurationManager.ConnectionStrings[&quot;ConnStr&quot;].ToString();</pre><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">完整的数据操作类SqlDataAccess.cs代码如下：</span></strong></p><pre class=\"brush:c#;toolbar:false\">using&nbsp;System;\r\nusing&nbsp;System.Collections.Generic;\r\nusing&nbsp;System.Linq;\r\nusing&nbsp;System.Text;\r\n\r\nusing&nbsp;System.Data;\r\nusing&nbsp;System.Data.SqlClient;\r\n\r\nnamespace&nbsp;DataAccess\r\n{\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;class&nbsp;SqlDataAccess\r\n&nbsp;&nbsp;&nbsp;&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;SqlConnection&nbsp;conn;//连接对象\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;连接并打开数据库\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;Open()\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//读取配置文件中的数据库连接字符串\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string&nbsp;ConStr&nbsp;=&nbsp;ConfigurationManager.AppSettings[&quot;ConnStr&quot;].ToString();\r\n&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conn&nbsp;=&nbsp;new&nbsp;SqlConnection(ConStr);//创建连接对象\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conn.Open();//打开数据库\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;执行添加、修改、删除语句\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;param&nbsp;name=&quot;sSql&quot;&gt;SQL语句&lt;/param&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;returns&gt;返回受影响的行数&lt;/returns&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;int&nbsp;ExecuteSql(string&nbsp;sSql)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open();//打开数据库\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SqlCommand&nbsp;comm&nbsp;=&nbsp;new&nbsp;SqlCommand(sSql,&nbsp;conn);//定义命令对象\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;iRet&nbsp;=&nbsp;comm.ExecuteNonQuery();//执行SQL语句\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conn.Close();//关闭数据库连接\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;iRet;//返回受影响的行数\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;summary&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;执行查询语句\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;/summary&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;param&nbsp;name=&quot;sSql&quot;&gt;SQL语句&lt;/param&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///&nbsp;&lt;returns&gt;返回查询结果（数据集）&lt;/returns&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;DataSet&nbsp;QuerySql(string&nbsp;sSql)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Open();//打开数据库\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SqlDataAdapter&nbsp;mAdapter&nbsp;=&nbsp;new&nbsp;SqlDataAdapter(sSql,&nbsp;conn);//创建DataAdapter数据适配器实例\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataSet&nbsp;ds&nbsp;=&nbsp;new&nbsp;DataSet();&nbsp;&nbsp;//创建DataSet数据集实例\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mAdapter.Fill(ds);//填充数据集\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conn.Close();//关闭数据库连接\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;ds;//返回查询结果（数据集）\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n\r\n}</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>代码分层（一般是三层，一层套一层）</strong><br/><br/>1. 数据库访问层（DAL）：就是说有SQL语句的，执行具体的增删改查数据操作<br/>2. 业务逻辑层(BLL)：负责处理业务逻辑，可能需要多个ADO的操作。Service层<br/>3. 表现层(Demo)：就是用户界面，B/S的是网页ASP，C/S的是winForm<br/><br/>SqlHelper.cs //微软提供的C#数据库操作类</span><br/></p>',0,'C# 基础 数据库操作','数据类型的转换： int a=int.Parse(str); //把字符串转换为整型      int a=Convert.ToInt32(str); //把字符串转换为整型         string myStr=a.ToString(); //把整型a转换回字符串类型输入输出： Console.ReadLine();  //输入一行 Console.WriteLine(); //输出一行  ...',11,29,'20161127/1480181636481.jpg'),(108,'常用的JSTL标签','2016-11-27 21:05:53','<div style=\"margin-top: 0px; margin-right: auto; margin-bottom: 0px; margin-left: auto; padding-top: 20px; padding-right: 20px; padding-bottom: 20px; padding-left: 20px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; font-family: &#39;Microsoft YaHei&#39;, Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 1.6; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); max-width: 960px; \"><ul style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 30px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \" class=\" list-paddingleft-2\"><li><p>&lt;c:if&gt;标签：有以下几个属性：</p></li><ul style=\"list-style-type: square;\" class=\" list-paddingleft-2\"><li><p>test：用于给出判断条件，该条件只能使用EL表达式/这个版本也可以使用Java脚本</p></li><li><p>scope：用于指出test条件生成的结果的保存范围</p></li><li><p>var：用于指定test条件的生成结果的引用（变量名）</p></li></ul></ul><blockquote style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">注意：&lt;c:if&gt;标签没有&lt;c:else&gt;标签与之对应，通常与&lt;c:choose&gt;，&lt;c:when&gt;，&lt;otherwise&gt;这三个标签配合使用，相当于Java中的switch...case...default语句。</span></p></blockquote><ul style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 30px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \" class=\" list-paddingleft-2\"><li><p>&lt;c:forEach&gt;标签：用于遍历集合元素，有以下几个属性：</p></li><ul style=\"list-style-type: square;\" class=\" list-paddingleft-2\"><li><p>index：int类型，表示当前循环索引号</p></li><li><p>count：int类型，表示成员总数</p></li><li><p>current：表示当前正在迭代的（集合中的）项</p></li><li><p>first：boolean类型，表示当前这轮迭代是否为第一次迭代的标志</p></li><li><p>last：boolean类型，表示当前这轮迭代是否为最后一次迭代的标志</p></li><li><p>begin：开始位置</p></li><li><p>end：结束位置</p></li><li><p>step：表示步长</p></li><li><p>items：表示要遍历的集合</p></li><li><p>var：表示每次迭代元素的引用</p></li><li><p>varStatus：表示循环状态变量，其中保存了循环进行时的状态信息</p></li></ul></ul><blockquote style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><pre style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 6px; padding-right: 10px; padding-bottom: 6px; padding-left: 10px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-size: 13px; font-family: Consolas, &#39;Liberation Mono&#39;, Courier, monospace; background-color: rgb(248, 248, 248); border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); line-height: 19px; overflow-x: auto; overflow-y: auto; border-top-left-radius: 3px 3px; border-top-right-radius: 3px 3px; border-bottom-right-radius: 3px 3px; border-bottom-left-radius: 3px 3px; \">&lt;c:forEach&nbsp;begin=&quot;0&quot;&nbsp;end=&quot;&quot;&nbsp;items=&quot;${users}&quot;&nbsp;var=&quot;user&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;${user}\r\n&lt;/c:forEach&gt;</pre><pre style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 6px; padding-right: 10px; padding-bottom: 6px; padding-left: 10px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-size: 13px; font-family: Consolas, &#39;Liberation Mono&#39;, Courier, monospace; background-color: rgb(248, 248, 248); border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); line-height: 19px; overflow-x: auto; overflow-y: auto; border-top-left-radius: 3px 3px; border-top-right-radius: 3px 3px; border-bottom-right-radius: 3px 3px; border-bottom-left-radius: 3px 3px; \">&lt;%\r\n&nbsp;&nbsp;&nbsp;&nbsp;List&lt;User&gt;&nbsp;users&nbsp;=&nbsp;new&nbsp;ArrayList&lt;User&gt;();\r\n&nbsp;&nbsp;&nbsp;&nbsp;users.add(new&nbsp;User(&quot;15&quot;,&quot;张三&quot;,&quot;1995-09-08&quot;,&quot;123123213@dsad&quot;));\r\n&nbsp;&nbsp;&nbsp;&nbsp;users.add(new&nbsp;User(&quot;13&quot;,&quot;李四&quot;,&quot;2015-05-03&quot;,&quot;gsadjasd@gdajsdg&quot;));\r\n&nbsp;&nbsp;&nbsp;&nbsp;users.add(new&nbsp;User(&quot;11&quot;,&quot;熊大&quot;,&quot;2005-04-06&quot;,&quot;211233123@dasd&quot;));\r\n&nbsp;&nbsp;&nbsp;&nbsp;users.add(new&nbsp;User(&quot;123&quot;,&quot;熊二&quot;,&quot;2001-09-04&quot;,&quot;s21312312d@123&quot;));\r\n&nbsp;&nbsp;&nbsp;&nbsp;pageContext.setAttribute(&quot;users&quot;,&nbsp;users);\r\n%&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;table&nbsp;cellpadding=&quot;3&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tr&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;th&gt;ID&lt;/th&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;th&gt;姓名&lt;/th&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;th&gt;生日&lt;/th&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;th&gt;邮箱&lt;/th&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tr&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tbody&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;c:forEach&nbsp;var=&quot;user&quot;&nbsp;items=&quot;${users&nbsp;}&quot;&nbsp;varStatus=&quot;u&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;c:choose&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;c:when&nbsp;test=&quot;${u.index&nbsp;%&nbsp;2&nbsp;eq&nbsp;0&nbsp;}&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tr&nbsp;style=&quot;color:blue&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;${user.id&nbsp;}&lt;/td&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;${user.name&nbsp;}&lt;/td&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;${user.birth&nbsp;}&lt;/td&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;${user.email&nbsp;}&lt;/td&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tr&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/c:when&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;c:otherwise&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tr&nbsp;style=&quot;color:green&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;${user.id&nbsp;}&lt;/td&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;${user.name&nbsp;}&lt;/td&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;${user.birth&nbsp;}&lt;/td&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;td&gt;${user.email&nbsp;}&lt;/td&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tr&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/c:otherwise&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/c:choose&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/c:forEach&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/tbody&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/table&gt;</pre><p style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">运行截图：</p><p style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><img src=\"/images/20161127/1480252231308015953.png\" title=\"1480252231308015953.png\" alt=\"img.png\"/></p></blockquote><ul style=\"list-style-type: disc;\" class=\" list-paddingleft-2\"><li><p>&lt;forTokens&gt;标签：相当于Java中的String.split()方法。forTokens标签与forEach标签类似，都有begin、end、step、items等属性，可以循环遍历items属性的值。不同的是forEach标签里的items属性里面是集合或者是数组，而forTokens标签里的items属性里面是字符串， 这个字符串会被delims属性内容分割成多个字符串。</p></li><ul style=\"list-style-type: square;\" class=\" list-paddingleft-2\"><li><p>delims：用于分隔的字符<br/></p></li></ul></ul><pre style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 6px; padding-right: 10px; padding-bottom: 6px; padding-left: 10px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-size: 13px; font-family: Consolas, &#39;Liberation Mono&#39;, Courier, monospace; background-color: rgb(248, 248, 248); border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); line-height: 19px; overflow-x: auto; overflow-y: auto; border-top-left-radius: 3px 3px; border-top-right-radius: 3px 3px; border-bottom-right-radius: 3px 3px; border-bottom-left-radius: 3px 3px; \">&lt;c:forTokens&nbsp;items=&quot;aa,bb,cc,dd&quot;&nbsp;delims=&quot;,&quot;&nbsp;var=&quot;data&quot;&nbsp;varStatus=&quot;status&quot;&nbsp;begin=&quot;1&quot;&nbsp;end=&quot;2&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;${data}\r\n&lt;/c:forTokens&gt;</pre></div>',0,'JSTL 标签','<c:if>标签：有以下几个属性：test：用于给出判断条件，该条件只能使用EL表达式/这个版本也可以使用Java脚本scope：用于指出test条件生成的结果的保存范围var：用于指定test条件的生成结果的引用（变量名）注意：<c:if>标签没有<c:else>标签与之对应，通常与<c:choose>，<c:when>，<otherwise>这三个标签配合使用，相当于Java中的switch....',7,11,'20161127/1480251953464.jpg'),(109,'EL表达式','2016-11-27 21:20:29','<div style=\"margin-top: 0px; margin-right: auto; margin-bottom: 0px; margin-left: auto; padding-top: 20px; padding-right: 20px; padding-bottom: 20px; padding-left: 20px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; font-family: &#39;Microsoft YaHei&#39;, Helvetica, arial, freesans, clean, sans-serif; font-size: 14px; line-height: 1.6; color: rgb(51, 51, 51); background-color: rgb(255, 255, 255); max-width: 960px; \"><p style=\"margin-top: 10px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">E L（Expression Language），表达式语言。目的：为了使JSP写起来更加简单。</span></p><ul style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 30px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \" class=\" list-paddingleft-2\"><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">语法结构：${expression}</span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">用途：</span></p></li><ul style=\"list-style-type: square;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">从EL隐含对象（param、cookie、initParam等）中取数据，还包括四大域范围对象（pageScope、requestScope、sessionScope、applicationScope）</span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">执行数据运算</span></p></li></ul><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">属性范围在EL中的名称：</span></p></li></ul><table><thead style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><tr style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 1px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); \" class=\"firstRow\"><th style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-weight: bold; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">域属性</span></th><th style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-weight: bold; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: left; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">EL中对应的表达方式</span></th></tr></thead><tbody style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><tr style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 1px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); \"><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">page</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: left; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">pageScope</span></td></tr><tr style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 1px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); \"><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">request</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: left; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">requestScope</span></td></tr><tr style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 1px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); \"><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">session</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: left; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">sessionScope</span></td></tr><tr style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 1px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); \"><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">application</span></td><td style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 13px; padding-bottom: 6px; padding-left: 13px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); text-align: left; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">applicationScope</span></td></tr></tbody></table><blockquote style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">例如：我们要取得session中储存一个属性username的值，可以利用下列方法：</span></p></blockquote><pre style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 6px; padding-right: 10px; padding-bottom: 6px; padding-left: 10px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-size: 13px; font-family: Consolas, &#39;Liberation Mono&#39;, Courier, monospace; background-color: rgb(248, 248, 248); border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); line-height: 19px; overflow-x: auto; overflow-y: auto; border-top-left-radius: 3px 3px; border-top-right-radius: 3px 3px; border-bottom-right-radius: 3px 3px; border-bottom-left-radius: 3px 3px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;session.getAttribute(&quot;username&quot;)&nbsp;//取得username的值<br/></span></pre><blockquote style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在EL中则使用下列方法：</span></p></blockquote><pre style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 6px; padding-right: 10px; padding-bottom: 6px; padding-left: 10px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-size: 13px; font-family: Consolas, &#39;Liberation Mono&#39;, Courier, monospace; background-color: rgb(248, 248, 248); border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); line-height: 19px; overflow-x: auto; overflow-y: auto; border-top-left-radius: 3px 3px; border-top-right-radius: 3px 3px; border-bottom-right-radius: 3px 3px; border-bottom-left-radius: 3px 3px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;${sessionScope.username}<br/></span></pre><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">[]与.运算符：EL 提供.和[]两种运算符来存取数据。</span></p><blockquote style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">当要存取的属性名称中包含一些特殊字符，如.或?等并非字母或数字的符号，就一定要使用 []。<br/>例如：</span></p><pre style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 6px; padding-right: 10px; padding-bottom: 6px; padding-left: 10px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-size: 13px; font-family: Consolas, &#39;Liberation Mono&#39;, Courier, monospace; background-color: rgb(248, 248, 248); border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); line-height: 19px; overflow-x: auto; overflow-y: auto; border-top-left-radius: 3px 3px; border-top-right-radius: 3px 3px; border-bottom-right-radius: 3px 3px; border-bottom-left-radius: 3px 3px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;&nbsp;&nbsp;${user.My-Name}应当改为${user[&quot;My-Name&quot;]&nbsp;}<br/>&nbsp;&nbsp;&nbsp;如果要动态取值时，就可以用[]来做，而.无法做到动态取值。<br/>&nbsp;&nbsp;&nbsp;例如：${sessionScope.user[data]}中data&nbsp;是一个变量<br/></span></pre></blockquote><ul style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 30px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \" class=\" list-paddingleft-2\"><li><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">变量</span></p><blockquote style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 15px; padding-bottom: 0px; padding-left: 15px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 4px; border-style: initial; border-color: initial; border-left-style: solid; border-left-color: rgb(221, 221, 221); color: rgb(119, 119, 119); \"><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">EL存取变量数据的方法很简单，例如：${username}。它的意思是取出某一范围中名称为username的变量。因为我们并没有指定哪一个范围的username，所以它会依序从page、request、session、application范围查找。<br/><strong>假如途中找到username，就直接回传，不再继续找下去，但是假如全部的范围都没有找到时，就回传null。</strong></span></p></blockquote></li><li><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">常用的几个EL隐含对象</span></p></li><ul style=\"list-style-type: square;\" class=\" list-paddingleft-2\"><li><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">与范围有关的隐含对象<br/>与范围有关的EL 隐含对象包含以下四个：<br/><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">pageScope、requestScope、sessionScope 和applicationScope</strong><br/>它们基本上就和JSP的pageContext、request、session和application域对象一样；在EL中，这四个隐含对象只能用来取得范围属性值，即getAttribute(String name)，却不能取得其他相关信息。</span></p></li><li><p style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">与输入有关的隐含对象<br/>与输入有关的隐含对象有两个：<strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">param</strong>和<strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">paramValues</strong>，它们是EL中比较特别的隐含对象。<br/><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">${param}表示返回请求参数中单个字符串的值. ${paramValues}表示返回请求参数的一组。</strong><br/>例如我们要取得用户的请求参数时，可以利用下列方法：</span></p><pre style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 6px; padding-right: 10px; padding-bottom: 6px; padding-left: 10px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-size: 13px; font-family: Consolas, &#39;Liberation Mono&#39;, Courier, monospace; background-color: rgb(248, 248, 248); border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); line-height: 19px; overflow-x: auto; overflow-y: auto; border-top-left-radius: 3px 3px; border-top-right-radius: 3px 3px; border-bottom-right-radius: 3px 3px; border-bottom-left-radius: 3px 3px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;&nbsp;&nbsp;request.getParameter(String&nbsp;name)<br/>&nbsp;&nbsp;&nbsp;request.getParameterValues(String&nbsp;name)<br/></span></pre><p style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在EL中则可以使用param和paramValues两者来取得数据。</span></p><pre style=\"margin-top: 15px; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding-top: 6px; padding-right: 10px; padding-bottom: 6px; padding-left: 10px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-style: initial; border-color: initial; font-size: 13px; font-family: Consolas, &#39;Liberation Mono&#39;, Courier, monospace; background-color: rgb(248, 248, 248); border-top-style: solid; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; border-top-color: rgb(204, 204, 204); border-right-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-left-color: rgb(204, 204, 204); line-height: 19px; overflow-x: auto; overflow-y: auto; border-top-left-radius: 3px 3px; border-top-right-radius: 3px 3px; border-bottom-right-radius: 3px 3px; border-bottom-left-radius: 3px 3px; \"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;&nbsp;&nbsp;${param.name}<br/>&nbsp;&nbsp;&nbsp;${paramValues.name}<br/></span></pre></li></ul></ul></div><p><br/></p>',0,'EL表达式 JSP','E L（Expression Language），表达式语言。目的：为了使JSP写起来更加简单。语法结构：${expression}用途：从EL隐含对象（param、cookie、initParam等）中取数据，还包括四大域范围对象（pageScope、requestScope、sessionScope、applicationScope）执行数据运算属性范围在EL中的名称：域属性EL中对应的表达方...',6,11,'20161127/1480254345964.jpg'),(110,'过滤器Filter','2016-11-27 21:29:52','<p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">过滤器用于处理对用户请求、响应做额外的设置。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">例如：设置用户请求与响应字符编码的处理。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Filter的开发分为以下两个步骤：</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">1. 编写java类实现javax.servlet.Filter接口，并实现其doFilter方法。</span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \">注意：不要忘记调用过滤链方法</strong>。如以下实现编码过滤器的代码：<strong style=\"margin-top: 0px; margin-right: 0px; margin-bottom: 0px; margin-left: 0px; padding-top: 0px; padding-right: 0px; padding-bottom: 0px; padding-left: 0px; border-top-width: 0px; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; border-style: initial; border-color: initial; \"><br/></strong></span></p><pre class=\"brush:java;toolbar:false\">package&nbsp;org.zrgj.filter;\r\n\r\nimport&nbsp;java.io.IOException;\r\n\r\nimport&nbsp;javax.servlet.Filter;\r\nimport&nbsp;javax.servlet.FilterChain;\r\nimport&nbsp;javax.servlet.FilterConfig;\r\nimport&nbsp;javax.servlet.ServletException;\r\nimport&nbsp;javax.servlet.ServletRequest;\r\nimport&nbsp;javax.servlet.ServletResponse;\r\nimport&nbsp;javax.servlet.http.HttpServletRequest;\r\nimport&nbsp;javax.servlet.http.HttpServletResponse;\r\nimport&nbsp;javax.servlet.http.HttpSession;\r\n\r\n/**\r\n&nbsp;*&nbsp;utf-8编码过滤器\r\n&nbsp;*&nbsp;@author&nbsp;xjc\r\n&nbsp;*/\r\npublic&nbsp;class&nbsp;EncodingFilter&nbsp;implements&nbsp;Filter&nbsp;{\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;destroy()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO&nbsp;Auto-generated&nbsp;method&nbsp;stub\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;/**\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;过滤处理\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;doFilter(ServletRequest&nbsp;request,&nbsp;ServletResponse&nbsp;response,&nbsp;FilterChain&nbsp;chain)&nbsp;throws&nbsp;IOException,&nbsp;ServletException&nbsp;{\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//转换对象\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpServletRequest&nbsp;req&nbsp;=&nbsp;(HttpServletRequest)request;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpServletResponse&nbsp;resp&nbsp;=&nbsp;(HttpServletResponse)response;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//设置编码格式为utf-8\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp.setCharacterEncoding(&quot;utf-8&quot;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp.setContentType(&quot;text/html;charset=utf-8&quot;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取请求URL\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;url&nbsp;=&nbsp;req.getRequestURL().toString();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HttpSession&nbsp;session&nbsp;=&nbsp;req.getSession();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(url);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//获取session中的用户名\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;name&nbsp;=&nbsp;(String)session.getAttribute(&quot;username&quot;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(url.indexOf(&quot;/login&quot;)&nbsp;!=&nbsp;-1&nbsp;||&nbsp;url.indexOf(&quot;/vCode&quot;)&nbsp;!=&nbsp;-1)&nbsp;{&nbsp;//是登录或验证码请求，无需过滤\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//调用过滤链\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chain.doFilter(req,&nbsp;resp);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(name&nbsp;==&nbsp;null&nbsp;||&nbsp;&quot;&quot;.equals(name))&nbsp;{&nbsp;//用户未登录，重定向到登录页面\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resp.sendRedirect(&quot;login.jsp&quot;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//其他情况，直接调用过滤链\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chain.doFilter(req,&nbsp;resp);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;init(FilterConfig&nbsp;fConfig)&nbsp;throws&nbsp;ServletException&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;TODO&nbsp;Auto-generated&nbsp;method&nbsp;stub\r\n&nbsp;&nbsp;&nbsp;&nbsp;}\r\n\r\n}</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">2. 在 web.xml 文件中使用和元素对编写的filter类进行注册，并设置它所能拦截的资源，一般情况是“/*”，即拦截所有资源。</span></p><pre class=\"brush:xml;toolbar:false\">&lt;filter&gt;\r\n&nbsp;&nbsp;&nbsp;&lt;filter-name&gt;encoding&lt;/filter-name&gt;\r\n&nbsp;&nbsp;&nbsp;&lt;filter-class&gt;org.xjc.filter.EncodingFilter&lt;/filter-class&gt;\r\n&lt;/filter&gt;\r\n&lt;filter-mapping&gt;\r\n&nbsp;&nbsp;&nbsp;&lt;filter-name&gt;encoding&lt;/filter-name&gt;\r\n&nbsp;&nbsp;&nbsp;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;\r\n&lt;/filter-mapping&gt;</pre><p><br/></p>',0,'Filter 过滤器','过滤器用于处理对用户请求、响应做额外的设置。例如：设置用户请求与响应字符编码的处理。Filter的开发分为以下两个步骤：1. 编写java类实现javax.servlet.Filter接口，并实现其doFilter方法。注意：不要忘记调用过滤链方法。如以下实现编码过滤器的代码：package org.zrgj.filter;import java.io.IOException;import jav...',8,11,'20161127/1480253392823.jpg'),(111,'分页显示数据','2016-11-27 21:45:11','<p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px; color: rgb(128, 128, 128);\"></span><strong>三种常用数据库的分页关键字</strong></span></p><ul style=\"list-style-type: disc;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">SQL Server数据库：使用top关键字，如：</span></p></li></ul><pre class=\"brush:sql;toolbar:false\">select&nbsp;top&nbsp;4&nbsp;*&nbsp;from&nbsp;user</pre><ul style=\"list-style-type: disc;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">MySQL数据库：使用limit关键字，如：<br/></span></p></li></ul><pre class=\"brush:sql;toolbar:false\">select&nbsp;*&nbsp;from&nbsp;user&nbsp;limit&nbsp;0,10</pre><ul style=\"list-style-type: disc;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">Oracle数据库：使用rownum关键字，如：</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p></li></ul><pre class=\"brush:sql;toolbar:false\">select&nbsp;*&nbsp;from&nbsp;(select&nbsp;u.*,&nbsp;rownum&nbsp;rn&nbsp;from&nbsp;user&nbsp;u&nbsp;where&nbsp;rownum&nbsp;&lt;=&nbsp;4)&nbsp;where&nbsp;rn&nbsp;&gt;=&nbsp;2</pre><p><strong><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">制作分页控制条</span></strong><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><br/></span></p><ul style=\"list-style-type: disc;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">主要需要以下几个参数：<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; color: rgb(0, 128, 0);\"></span></span></p></li><ul style=\"list-style-type: square;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">当前页：currentPage<br/></span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">记录总条数：totalCount<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\"></span><br/><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\"></span></span></p></li><li><p><span style=\"font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">每页的记录条数：pageSize</span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px; color: rgb(0, 128, 0);\"></span></span><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p></li></ul><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">根据记录总条数totalCount及每页的记录条数pageSize计算页数pageCount</span></p></li></ul><pre class=\"brush:java;toolbar:false\">pageCount&nbsp;=&nbsp;talCount&nbsp;%&nbsp;pageSize&nbsp;==&nbsp;0&nbsp;?&nbsp;totalCount&nbsp;/&nbsp;pageSize&nbsp;:&nbsp;totalCount&nbsp;/&nbsp;pageSize&nbsp;+&nbsp;1;</pre><p><br/></p>',0,'数据库 分页','三种常用数据库的分页关键字SQL Server数据库：使用top关键字，如：select top 4 * from userMySQL数据库：使用limit关键字，如：select * from user limit 0,10Oracle数据库：使用rownum关键字，如：select * from (select u.*, rownum rn from user u where rownum <...',39,11,'20161127/1480254311698.jpg'),(112,'struts在页面接收请求参数','2016-11-30 17:04:03','<p>1. 使用%{#parameters.参数名}来获取，如：%{#parameters.userId}</p>',0,'struts 页面传值','1. 使用%{#parameters.参数名}来获取，如：%{#parameters.userId}',8,17,'20161130/1480496643980.jpg'),(113,'Java中DOM解析常用的四种方式','2016-12-06 13:50:31','<p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Java中DOM解析主要有四种方式：<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">SAX</span>、DOM、JDOM、Dom4J</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: small;\">SAX</span></strong></span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">sax分析器在对xml文档进行分析时,触发一系列的事件,应用程序通过事件处理函数实现对xml文档的访问.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">因为事件触发是有时序性的,所以sax分析器提供的是一种对xml文档的顺序访问机制,对于已经分析过的部分,</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">不能再重新倒回去处理.此外，它也不能同时访问处理2个tag.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">sax分析器在实现时,只是顺序地检查xml文档中的字节流,判断当前字节是xml语法中的哪一部分,检查是否符合</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">xml语法并且触发相应的事件.对于事件处理函数的本身,要由应用程序自己来实现.&nbsp;SAX解析器采用了基于事件的模型，它在解析XML文档的时候可以触发一系列的事件，当发现给定的tag的时候，它可以激活一个回调方法，告诉该方法制定的标签已经找到。</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">同DOM分析器相比,sax分析器对xml文档的处理缺乏灵活性,但对于只访问xml文档中的数据而不改变应用程序</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">来说,sax分析器的效率会很高.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">sax对内存要求也比较低.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">优点:1、无需将整个文档加载到内存中,所以内存消耗少.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp;2 、推模型允许注册多个contentHandler.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">缺点:1、没有内置的文档导航支持.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp;2、不能随机访问xml文档.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp;3、不支持原地修改xml.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp;4、不支持名字空间作用域.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">适合：对xml文档读取数据</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: small;\">DOM</span></strong></span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; line-height: 25.2000007629395px; white-space: normal; background-color: rgb(255, 255, 255);\"><span style=\"line-height: 25px; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">DOM解析器把XML文档转化为一个包含其内容的树，并可以对树进行遍历。也就是说，通过DOM树，应用程序可以对XML文档进行随机访问。这种访问方式给应用程序的开发带来了很大的灵活性，它可以任意地控制整个XML文档中的内容.用DOM解析模型编程容易，开发人员只需要调用建树的指令，然后利用navigation\r\n \r\nAPIs访问所需的树节点来完成任务。可以很容易的添加和修改树中的元素。然而由于使用DOM解析器的时候需要处理整个XML文档，所以对性能和内存的要求比较高，尤其是遇到很大的XML文件的时候。由于它的遍历能力，DOM解析器常用于XML文档需要频繁的改变的服务中。</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">优点:1、丰富的API集合,可以轻松导航.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp; 2、 整个DOM树加载到内存,允许随机访问.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">缺点:1、整个xml文档必须一次解析完.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp; 2、整个DOM树都加载到内存中,内存要求高.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp; 3、一般的DOM节点对于必须为所有节点创建对象的对象类型绑定不太理想.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">适用：对xml文档修改数据</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: small;\">JDOM</span></strong></span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">JDOM是处理xml的纯java\r\n \r\napi.使用具体类而不是接口.JDOM具有树的遍历,又有SAX的java规则.JDOM与DOM主要有两方面不同。首先，JDOM仅使用具体类而不使用接口。这在某些方面简化了API，但是也限制了灵活性。第二，API大量使用了Collections类，简化了那些已经熟悉这些类的Java开发者的使用。</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">JDOM自身不包含解析器。它通常使用SAX2解析器来解析和验证输入XML文档（尽管它还可以将以前构造的DOM表示作为输入）。它包含一些转换器以将JDOM表示输出成SAX2事件流、DOM模型或XML文本文档。JDOM是在Apache许可证变体下发布的开放源码。</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">优点:1、是基于树的处理xml的java api,把树加载到内存中.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp; 2、没有向下兼容的限制,所以比DOM简单.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp; 3、速度快.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp; 4、具有SAX的java 规则.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">缺点:1、不能处理大于内存的文档.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp; 2、JDOM表示XML文档逻辑模型,不能保证每个字节真正变换.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp; 3、 针对实例文档不提供DTD与模式的任何实际模型.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp; 4、 不支持于DOM中相应遍历包.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">适用：自行选择</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: small;\">DOM4J</span></strong></span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">DOM4J有更复杂的api,所以dom4j比jdom有更大的灵活性.DOM4J性能最好，连Sun的JAXM也在用DOM4J.目前许多开源项目中大量采用DOM4J，例如大名鼎鼎的Hibernate也用DOM4J来读取XML配置文件。如果不考虑可移植性，那就采用DOM4J.</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">优点：1、灵活性最高</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-size: small; font-family: 微软雅黑,Microsoft YaHei; white-space: pre;\"> </span>&nbsp; &nbsp; &nbsp;2、易用性和功能强大、性能优异</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">缺点：1、复杂的api</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-size: small; font-family: 微软雅黑,Microsoft YaHei; white-space: pre;\"> </span>&nbsp; &nbsp; &nbsp;2、移植性差</span></p><p style=\"margin-top: 0px; margin-bottom: 0px; padding: 0px; font-family: Helvetica, Tahoma, Arial, sans-serif; font-size: 14px; white-space: normal; line-height: 25px; background-color: rgb(255, 255, 255);\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">适用：自行选择</span></p><p><br/></p>',0,'DOM 解析','Java中DOM解析主要有四种方式：SAX、DOM、JDOM、Dom4JSAXsax分析器在对xml文档进行分析时,触发一系列的事件,应用程序通过事件处理函数实现对xml文档的访问.因为事件触发是有时序性的,所以sax分析器提供的是一种对xml文档的顺序访问机制,对于已经分析过的部分,不能再重新倒回去处理.此外，它也不能同时访问处理2个tag.sax分析器在实现时,只是顺序地检查xml文档中的字节...',2,34,'20161206/1481003430400.jpg'),(114,'序列化和反序列化在网络中的应用','2016-12-07 16:51:17','<p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span></strong></p><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">定义：</span></strong></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">序列化： 本质就是将数据结构或对象转换成二进制串的过程。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">通过序列化可以有三个用途：</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">1、<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">对象持久化</span>：将对象写入到<strong>文件</strong>中，长期保存到硬盘上；</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">2、对象复制：将对象保存在<strong>内存</strong>中，可以再通过此数据得到多个对象的副本；<br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">3、对象传输：将对象转化字节流后，可以通过<strong>网络传输</strong>给另外的Java程序。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">反序列化：序列化的逆过程。是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">注意</span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">：类中使用static或transient关键字修饰的属性不会被序列化。</span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">序列化和反序列化</span></strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在网络传输过程中常用的主要有<strong>SOAP协议（XML）和JSON</strong>两种</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\"><strong>XML&amp;SOAP</strong></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">SOAP，即Simple Object Access Protocol（简单对象访问协议）。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">SOAP在互联网影响如此大，以至于我们给基于SOAP的解决方案一个特定的名称--<strong>Web Service</strong>。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">SOAP虽然可以支持多种传输层协议，不过SOAP最常见的使用方式还是XML+HTTP。SOAP协议的主要接口描述语言（IDL）是WSDL（Web\r\n Service Description \r\nLanguage）。SOAP具有安全、可扩展、跨语言、跨平台并支持多种传输层协议。如果不考虑跨平台和跨语言的需求，XML的在某些语言里面具有非常简单易用的序列化使用方法，无需IDL文件和第三方编译器，\r\n 例如Java＋XStream。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">SOAP是一种采用XML进行序列化和反序列化的协议，它的IDL（Interface description language，接口描述语言：参与通讯的各方需要对通讯的内容需要做相关的约定（Specifications）。）是WSDL，而WSDL的描述文件是XSD，而XSD自身也是一种XML文件。</span></p><p><span style=\"font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">JSON</span></strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"></span></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">JSON，即JavaScript Object Notation。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p><div class=\"para\"><strong><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">JSON简单说就是javascript中的对象和数组</span></strong><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">，所以这两种结构就是对象和数组两种结构，通过这两种结构可以表示各种复杂的结构。</span></div><div class=\"para\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">1、JSON只有两种数据类型描述符，大括号{}和方括号[]，其余英文冒号:是映射符，英文逗号,是分隔符，英文双引号&quot;&quot;是定义符。</span></p><p><span style=\"font-size: 14px;\">2、大括号{}用来描述一组“不同类型的无序键值对集合”（每个键值对可以理解为OOP的属性描述），方括号[]用来描述一组“相同类型的有序数据集合”（可对应OOP的数组）。</span></p><p><span style=\"font-size: 14px;\">3、上述两种集合中若有多个子项，则通过英文逗号,进行分隔。</span></p><p><span style=\"font-size: 14px;\">4、键值对以英文冒号:进行分隔，并且建议键名都加上英文双引号”&quot;，以便于不同语言的解析。</span></p><p><strong><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">特点</span></strong><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">：</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">1. 它具备Javascript的先天性支持，所以被广泛应用于Web browser的应用常景中，是Ajax的事实标准协议。<br/>2. 与XML相比，其协议比较简单，解析速度比较快。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">JSON在很多应用场景中可以替代XML，更简洁并且解析速度更快。<strong>典型应用场景</strong>包括：<br/>1、公司之间传输数据量相对小，实时性要求相对低（例如秒级别）的服务。<br/>2、基于Web browser的Ajax请求。<br/>3、由于JSON具有非常强的前后兼容性，对于接口经常发生变化，并对可调式性要求高的场景，例如Mobile app与服务端的通讯。<br/>4、由于JSON的典型应用场景是JSON＋HTTP，适合跨防火墙访问。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">总的来说，采用JSON进行序列化的额外空间开销比较大，对于大数据量服务或持久化，这意味着巨大的内存和磁盘开销，这种场景不适合。没有统一可用的IDL降低了对参与方的约束，实际操作中往往只能采用文档方式来进行约定，这可能会给调试带来一些不便，延长开发周期。\r\n 由于JSON在一些语言中的序列化和反序列化需要采用反射机制，所以在性能要求为ms级别，不建议使用。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">以上两种序列化和反序列化协议都各自具有相应的特点，适用于不同的场景：<br/>1、对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。<br/>2、基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选。对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。<br/>3、对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。</span><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><br/></span><br/></p></div><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span><br/><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span><br/></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span><br/></p>',0,'序列化 数据传输','定义：序列化： 本质就是将数据结构或对象转换成二进制串的过程。通过序列化可以有三个用途：1、对象持久化：将对象写入到文件中，长期保存到硬盘上；2、对象复制：将对象保存在内存中，可以再通过此数据得到多个对象的副本；3、对象传输：将对象转化字节流后，可以通过网络传输给另外的Java程序。反序列化：序列化的逆过程。是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。注意：类中使用static...',7,38,'20161207/1481100677400.jpg'),(115,'jsonp原理及简单使用','2016-12-07 17:31:29','<p style=\"line-height: 2em;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\"><strong>什么是jsonp？</strong></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">jsonp，是JSON with Padding 的简称。它可用于解决主流浏览器的跨域数据访问的问题。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">由于同源策略，一般来说位于 server1.example.com 的网页无法与不是 server1.example.com的服务器沟通，而 \r\nHTML 的&lt;script&gt; 元素是一个例外。利用 &lt;script&gt; \r\n元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 \r\nJSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。</span></p><p style=\"line-height: 2em; margin-top: 5px; margin-bottom: 5px;\"><span style=\"font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">jsonp是怎么产生的？</span></strong></span><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><br/></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">1、一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准；</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">2、不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;）；</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</span></p><p style=\"line-height: 2em;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\">jsonp的简单使用</span></strong><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><br/></span></p><p style=\"line-height: 2em;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">1. 首先在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。</span></p><p style=\"line-height: 2em;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">jsonp.html文件代码如下：<br/></span></p><pre class=\"brush:html;toolbar:false\">&lt;!DOCTYPE&nbsp;html&nbsp;PUBLIC&nbsp;&quot;-//W3C//DTD&nbsp;XHTML&nbsp;1.0&nbsp;Transitional//EN&quot;&nbsp;&quot;&nbsp;\r\n&lt;html&nbsp;xmlns=&quot;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;head&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;跨域访问示例&lt;/title&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;text/javascript&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;localHandler&nbsp;=&nbsp;function(data){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(&#39;我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：&#39;&nbsp;+&nbsp;data.result);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;text/javascript&quot;&nbsp;src=&quot;http://remoteserver.com/remote.js&quot;&gt;&lt;/script&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/head&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;body&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/body&gt;\r\n&nbsp;&lt;/html&gt;</pre><p style=\"line-height: 2em;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">remote.js文件代码如下：</span></p><pre class=\"brush:js;toolbar:false\">localHandler({&quot;result&quot;:&quot;我是远程js带来的数据&quot;});</pre><p style=\"line-height: 2em;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">2. 聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">再看jsonp.html页面的代码：</span></p><pre class=\"brush:html;toolbar:false\">&lt;!DOCTYPE&nbsp;html&nbsp;PUBLIC&nbsp;&quot;-//W3C//DTD&nbsp;XHTML&nbsp;1.0&nbsp;Transitional//EN&quot;&nbsp;&quot;&nbsp;\r\n&lt;html&nbsp;xmlns=&quot;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;head&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;跨域示例&lt;/title&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;text/javascript&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;得到航班信息查询结果后的回调函数\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;flightHandler&nbsp;=&nbsp;function(data){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(&#39;你查询的航班结果是：票价&nbsp;&#39;&nbsp;+&nbsp;data.price&nbsp;+&nbsp;&#39;&nbsp;元，&#39;&nbsp;+&nbsp;&#39;余票&nbsp;&#39;&nbsp;+&nbsp;data.tickets&nbsp;+&nbsp;&#39;&nbsp;张。&#39;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;url&nbsp;=&nbsp;&quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler&quot;;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;创建script标签，设置其属性\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;script&nbsp;=&nbsp;document.createElement(&#39;script&#39;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;script.setAttribute(&#39;src&#39;,&nbsp;url);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;把script标签加入head，此时调用开始&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.getElementsByTagName(&#39;head&#39;)[0].appendChild(script);&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/head&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;body&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/body&gt;\r\n&lt;/html&gt;</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：</span></p><pre class=\"brush:js;toolbar:false\">flightHandler({\r\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;code&quot;:&nbsp;&quot;CA1998&quot;,\r\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;price&quot;:&nbsp;1780,\r\n&nbsp;&nbsp;&nbsp;&nbsp;&quot;tickets&quot;:&nbsp;5\r\n});</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">此外，通过jquery中的ajax方法我们也可以实现：</span></p><pre class=\"brush:js;toolbar:false\">&nbsp;&lt;script&nbsp;type=&quot;text/javascript&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jQuery(document).ready(function(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$.ajax({\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;&quot;get&quot;,\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;async:&nbsp;false,\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url:&nbsp;&quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&quot;,\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataType:&nbsp;&quot;jsonp&quot;,\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jsonp:&nbsp;&quot;callback&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jsonpCallback:&quot;flightHandler&quot;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;success:&nbsp;function(json){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(&#39;您查询到航班信息：票价：&nbsp;&#39;&nbsp;+&nbsp;json.price&nbsp;+&nbsp;&#39;&nbsp;元，余票：&nbsp;&#39;&nbsp;+&nbsp;json.tickets&nbsp;+&nbsp;&#39;&nbsp;张。&#39;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error:&nbsp;function(){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alert(&#39;fail&#39;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&lt;/script&gt;</pre><p><br/></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><br/></span><br/></p>',0,'jsonp 跨域访问','什么是jsonp？jsonp，是JSON with Padding 的简称。它可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于 server1.example.com 的网页无法与不是 server1.example.com的服务器沟通，而 \r\nHTML 的<script> 元素是一个例外。利用 <script> \r\n元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON ...',8,12,'20161207/1481103089728.jpg'),(116,'使用JSch实现SFTP文件传输','2016-12-09 12:34:06','<p style=\"line-height: 2em;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\">SFTP</span></strong></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">SFTP，是Security File Transfer Protocol（安全文件传送协议）的缩写，它是使用SSH协议进行FTP（<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">File Transfer Protocol</span>）传输的协议。<br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">SFTP同样是使用加密传输认证信息和传输的数据，所以，使用SFTP是非常安全的。但是，由于这种传输方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多，如果您对网络安全性要求更高时，可以使用SFTP代替FTP。</span></p><p style=\"line-height: 2em;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\">sftp服务器</span></strong></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span class=\"m\"> </span>sftp服务器的用途是起到数据存储和分发的作用：</span></p><ol style=\"list-style-type: decimal;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">服务器提供一定的安全措施并且保存用户账号和密码；</span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">客户端可以用sftp工具进行连接，下载或者上传数据。</span></p></li></ol><p style=\"line-height: 2em;\"><span style=\"font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">JSch</span></strong></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">JSch，即Java Secure Channel的缩写。它<span style=\"font-family: courier new, courier; font-size: 13px;\">是一个SSH2的纯Java实现。它允许你连接到一个SSH服务器，并且可以使用端口转发，X11转发，文件传输等，当然你也可以集成它的功能到你自己的应用程序。</span></span></p><p><span style=\"font-family: courier new,courier; font-size: 13px;\">JSch中常用的有以下几个类：</span></p><ol style=\"list-style-type: decimal;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei; color: rgb(0, 0, 0);\">JSch类</span></p></li><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei; color: rgb(0, 0, 0);\">Session会话类</span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(0, 0, 0);\">ChannelSftp类</span><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">：它是JSch实现SFTP的核心类，它包含了所有SFTP操作的方法。如下：</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p><div><table width=\"311\"><tbody><tr style=\";height: 27px\" class=\"firstRow\"><td style=\"\" width=\"101\"><span style=\"font-size: 14px;\">方法名<br/></span></td><td style=\"border-left-style: none;\" width=\"211\"><p><span style=\"font-size: 14px;\">方法说明</span></p></td></tr><tr><td><span style=\"font-size: 14px;\">connect() &nbsp;&nbsp;</span></td><td><span style=\"font-size: 14px;\">建立SFTP通道的连接</span></td></tr><tr><td><span style=\"font-size: 14px;\">disconnect()&nbsp; <br/></span></td><td><span style=\"font-size: 14px;\">关闭SFTP通道</span></td></tr><tr style=\";height: 27px\"><td style=\"border-top-style: none;\"><span style=\"font-size: 14px;\">put() &nbsp;&nbsp;</span></td><td style=\"border-top-style: none;border-left-style: none\"><span style=\"font-size: 14px;\">文件上传</span></td></tr><tr style=\";height: 27px\"><td style=\"border-top-style: none;\" width=\"101\"><span style=\"font-size: 14px;\">get()&nbsp;</span></td><td style=\"border-top-style: none;border-left-style: none\"><span style=\"font-size: 14px;\">文件下载</span></td></tr><tr style=\";height: 27px\"><td style=\"border-top-style: none;\" width=\"101\"><span style=\"font-size: 14px;\">cd() &nbsp;&nbsp;</span></td><td style=\"border-top-style: none;border-left-style: none\"><span style=\"font-size: 14px;\">进入指定目录</span></td></tr><tr style=\";height: 27px\"><td style=\"border-top-style: none;\" width=\"101\"><span style=\"font-size: 14px;\">ls() &nbsp;&nbsp;</span></td><td style=\"border-top-style: none;border-left-style: none\"><span style=\"font-size: 14px;\">得到指定目录下的文件列表</span></td></tr><tr style=\";height: 27px\"><td style=\"border-top-style: none;\" width=\"101\"><span style=\"font-size: 14px;\">rename()&nbsp;</span></td><td style=\"border-top-style: none;border-left-style: none\"><span style=\"font-size: 14px;\">重命名（移动）指定文件或目录</span></td></tr><tr style=\";height: 27px\"><td style=\"border-top-style: none;\" width=\"101\"><span style=\"font-size: 14px;\">rm() &nbsp;&nbsp;</span></td><td style=\"border-top-style: none;border-left-style: none\"><span style=\"font-size: 14px;\">删除指定文件</span></td></tr><tr style=\";height: 27px\"><td style=\"border-top-style: none;\" width=\"101\"><span style=\"font-size: 14px;\">mkdir() &nbsp; &nbsp;</span></td><td style=\"border-top-style: none;border-left-style: none\"><span style=\"font-size: 14px;\">创建目录</span></td></tr><tr style=\";height: 27px\"><td style=\"border-top-style: none;\" width=\"101\"><span style=\"font-size: 14px;\">rmdir()&nbsp; &nbsp;</span></td><td style=\"border-top-style: none;border-left-style: none\"><span style=\"font-size: 14px;\">删除目录（只允许删除空目录）</span></td></tr></tbody></table><p>&nbsp;<span style=\"font-size: 14px;\"> 注：以上这些方法都有很多重载方法</span></p><span style=\"font-family: courier new,courier; font-size: 13px;\"></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: windowtext; line-height: 1.5;\"></span></strong></span></div></li><li><div><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: windowtext; line-height: 1.5;\">SftpProgressMonitor </span><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: windowtext; line-height: 1.5;\">传输进度监控类</span></span><div><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: windowtext; line-height: 1.5;\"></span></strong></span></div></div></li><li><div><div><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: windowtext; line-height: 1.5;\">LsEntry</span></span><span style=\"color: windowtext; font-family: &#39;Courier New&#39;; font-size: 10pt; line-height: 1.5;\"> 可以认为是文件服务器上的文件条目信息，把包含文件或者目录相关属性 。ls命令返回的Vector中的就是LsEntry对象列表</span></div><span style=\"font-family: courier new,courier; font-size: 13px;\"></span></div></li></ol><p style=\"line-height: 2em;\"><strong><span style=\"color: windowtext; line-height: 1.5; font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\">SFTP文件传输的代码示例</span></strong></p><pre class=\"brush:java;toolbar:false\">&nbsp;&nbsp;&nbsp;//1、创建JSch类&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;JSch&nbsp;jsch&nbsp;=&nbsp;new&nbsp;JSch();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;//2、创建本次的文件传输会话对象，并连接到SFTP服务器。\r\n&nbsp;&nbsp;&nbsp;&nbsp;Session&nbsp;session&nbsp;=&nbsp;jsch.getSession(username,&nbsp;host,&nbsp;port);//&nbsp;根据用户名，主机ip，端口获取一个Session对象\r\n&nbsp;&nbsp;&nbsp;session.setPassword(passwd);//&nbsp;设置密码\r\n&nbsp;&nbsp;&nbsp;Properties&nbsp;config&nbsp;=&nbsp;new&nbsp;Properties();\r\n&nbsp;&nbsp;&nbsp;//&nbsp;设置第一次登陆的时候提示，可选值：(ask&nbsp;|&nbsp;yes&nbsp;|&nbsp;no)\r\n&nbsp;&nbsp;&nbsp;config.put(&quot;StrictHostKeyChecking&quot;,&nbsp;&quot;no&quot;);\r\n&nbsp;&nbsp;&nbsp;session.setConfig(config);//&nbsp;为Session对象设置properties\r\n&nbsp;&nbsp;&nbsp;session.connect();//&nbsp;通过Session建立连接\r\n&nbsp;&nbsp;&nbsp;&nbsp;ChannelSftp&nbsp;sftp&nbsp;=&nbsp;null;\r\n&nbsp;&nbsp;&nbsp;try{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//3、在该session会话中开启一个SFTP通道，之后就可以在该通道中进行文件传输了\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sftp&nbsp;=&nbsp;(ChannelSftp)session.openChannel(&quot;sftp&quot;);&nbsp;//&nbsp;打开SFTP通道\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sftp.connect();//&nbsp;建立SFTP通道的连接\r\n&nbsp;&nbsp;&nbsp;}catch(Exception&nbsp;e){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();\r\n&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;//4、进行文件传输操作：put()、get()....\r\n&nbsp;&nbsp;&nbsp;&nbsp;sftp.put(...)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;//5、操作完毕后，关闭通道并退出本次会话\r\n&nbsp;&nbsp;&nbsp;if(sftp!=null&nbsp;&amp;&amp;&nbsp;sftp.isConnected()){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sftp.disconnect();\r\n&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;if(session&nbsp;!=&nbsp;null&nbsp;&amp;&amp;&nbsp;session.isConnected()){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session.disconnect();\r\n&nbsp;&nbsp;&nbsp;}</pre><p style=\"line-height: 2em;\"><strong><span style=\"color: windowtext; line-height: 1.5; font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\"></span></strong><br/></p>',1,'SFTP JSch 文件传输','SFTPSFTP，是Security File Transfer Protocol（安全文件传送协议）的缩写，它是使用SSH协议进行FTP（File Transfer Protocol）传输的协议。SFTP同样是使用加密传输认证信息和传输的数据，所以，使用SFTP是非常安全的。但是，由于这种传输方式使用了加密/解密技术，所以传输效率比普通的FTP要低得多，如果您对网络安全性要求更高时，可以使用SF...',36,35,'20161209/1481259051634.jpg'),(119,'定时任务框架Quartz基础','2016-12-09 14:51:51','<p style=\"line-height: normal;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Quartz是一个完全由Java编写的开源任务调度框架，为在Java应用程序中进行作业调度提供了简单却强大的机制。它允许开发人员根据时间间隔来调度作业，它实现了作业和触发器的多对多的关系，还能把多个作业与不同的触发器关联。</span></p><p style=\"line-height: 2em;\"><span style=\"font-size: 16px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>核心概念</strong></span></p><p style=\"line-height: normal;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Quartz的原理不是很复杂，只要搞明白几个概念，然后知道如何去启动和关闭一个调度程序即可。</span></p><p style=\"line-height: normal;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">1、Job表示一个工作，要执行的具体内容。此接口中只有一个方法：</span></p><p style=\"line-height: normal;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">void execute(JobExecutionContext context)</span></p><p style=\"line-height: normal;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">2、JobDetail表示一个具体的可执行的调度程序，Job是这个可执行程调度程序所要执行的内容，另外JobDetail还包含了这个任务调度的方案和策略。<br/></span></p><p style=\"line-height: normal;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">3、Trigger代表一个调度参数的配置，什么时候去调。</span></p><p style=\"line-height: normal;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">4、Scheduler代表一个调度容器，一个调度容器中可以注册多个JobDetail和Trigger。需要把JobDetail和Trigger注册到Scheduler中，才可以执行。</span></p><p style=\"line-height: 2em;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; line-height: 25.2px;\">应用场景&nbsp;</span></strong></span></p><div><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif\"><span style=\"font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">&nbsp; &nbsp; 1、<span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">邮件提醒和告警</span></span></span></span></div><div><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif\"><span style=\"font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">&nbsp;\r\n &nbsp; 2、<span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">执行文件传输操作</span></span></span></span></span></div><div><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif\"><span style=\"font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">&nbsp;\r\n &nbsp; 3、<span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">创建销售报表</span></span></span></span></span></span></div><div><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif\"><span style=\"font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">&nbsp;\r\n &nbsp; 4、定时拉取银行对账文件，定时对账等</span></span></span></span></span></span></div><div><p><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif\"><span style=\"font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">&nbsp;\r\n &nbsp; 5、定时生成报表</span></span></span></span></span></span><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif\"><span style=\"font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><br/></span></span></span></p><p style=\"line-height: 2em;\"><strong><span style=\"line-height: 25.2px; font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\">体系结构&nbsp;</span></strong></p></div><div><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif\"><span style=\"font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">&nbsp;<span style=\"color:#330033\">1、简介:<span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">Quartz对任务调度的领域问题进行了高度的抽象，提出了调度器、任务和触发器这3个核心的概念,跟精细的描述<span style=\"color:rgb(51,0,51); font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">调度器、任务和触发器，跟精准的完成任务的调度。</span></span></span></span></span></span></div><div><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif\"><span style=\"font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"color:#330033\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"color:rgb(51,0,51); font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">&nbsp;\r\n 2、<span style=\"color:rgb(51,0,51); font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">调度器、任务和触发器简介</span></span></span></span></span></span></span></div><ul style=\"list-style-type: disc;\" class=\" list-paddingleft-2\"><li><div><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif\"><span style=\"font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"color:#330033\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">&nbsp; <span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">调度器：</span><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">调度器用于将与作业触发器关联,一个作业可关联多个触发器,这样每个触发器被可以触发的作业执行;一个触发器可用于控制多个作业，触发时<span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">全部作业将获得调度。Quartz的调度器由Scheduler接口体现。</span></span></span></span></span></span></span></span></span></div></li><li><div><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif\"><span style=\"font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"color:#330033\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px; color:red\">&nbsp; </span><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">作业：</span><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">只需实现org.quartz.job接口即可.Job接口包含一个方法 execute(),execute方法体是被调度的作业体。一旦实现Job接口和execute()方法， </span><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">Quartz确定作业运作的时候，它将调用 execute()方法体。&nbsp;</span><br/></span></span></span></span></span></span></span></span></span></div></li><li><div><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif\"><span style=\"font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"color:#330033\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">&nbsp; <span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">触发器：</span><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">有SimpleTrigger和CronTrigger两种类型&nbsp;</span></span></span></span></span></span></span></span></span></span></span></div></li></ul><div><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif\"><span style=\"font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"color:#330033\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif; font-size:14px; line-height:25.2px\">&nbsp;\r\n &nbsp; &nbsp; &nbsp; &nbsp;</span></span></span></span></span></span></span></span></span></span></span><span style=\"font-family:verdana,geneva; font-size:13px; line-height:18px; color:rgb(51,0,51)\">1.每隔指定时间则触发一次，对应的调度器为org.springframework.scheduling.quartz.SimpleTriggerBean</span></div><div><span style=\"color:rgb(51,0,51); font-size:14px; line-height:25.2px\"><span style=\"font-family:Helvetica,Tahoma,Arial,sans-serif\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></span><span style=\"font-family:verdana,geneva; font-size:13px; line-height:18px; color:rgb(51,0,51)\">2.每到指定时间则触发一次，对应的调度器为org.springframework.scheduling.quartz.CronTriggerBean</span></div><div><span style=\"font-family:verdana,geneva; font-size:13px; line-height:18px; color:rgb(51,0,51)\">&nbsp; &nbsp; &nbsp; &nbsp;<img src=\"/ueditor/jsp/upload/image/20161211/1481471763522045788.gif\" alt=\"\"/></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span></div><p style=\"line-height: 2em;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">使用步骤</span></strong></p><p style=\"line-height: 2em;\"><span style=\"font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">1、创建一个实现org.quarz.Job接口的MyJob<span style=\"font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">类</span></span>，Job接口包含唯一的execute方法：</span></span></p><pre class=\"brush:java;toolbar:false\">public&nbsp;void&nbsp;execute(JobExecutionContext&nbsp;context)&nbsp;throws&nbsp;JobExecutionException;</pre><div><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">在Job接口实现类里面，添加需要的逻辑到execute()方法中。配置好Job实现类并设定好调度时间表，Quartz就会自动在设定的时间调度作业执行execute()。</span></p><p>2、<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">分别创建Scheduler、JobDetail、CronTrigger对象，并将JobDetail、CronTrigger对象注册到Scheduler中，调用Scheduler对象的start()方法启动定时任务。程序将在指定时间完成任务调度工作。</span></p><pre class=\"brush:java;toolbar:false\">SchedulerFactory&nbsp;schedulerFactory&nbsp;=&nbsp;new&nbsp;StdSchedulerFactory();\r\n//通过schedulerFactory获取一个调度器&nbsp;&nbsp;\r\nScheduler&nbsp;scheduler=schedulerfactory.getScheduler();&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n//创建jobDetail实例，绑定Job实现类&nbsp;&nbsp;\r\n//指明job的名称，所在组的名称，以及绑定job类&nbsp;&nbsp;\r\nJobDetail&nbsp;jobDetail=new&nbsp;JobDetail(&quot;job1&quot;,&nbsp;&quot;jgroup1&quot;,&nbsp;MyJob.class);&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n//定义调度触发规则，每天上午10：15执行&nbsp;&nbsp;\r\nCronTrigger&nbsp;cornTrigger=new&nbsp;CronTrigger(&quot;cronTrigger&quot;,&quot;triggerGroup&quot;);&nbsp;&nbsp;\r\n//执行规则表达式&nbsp;&nbsp;\r\ncornTrigger.setCronExpression(&quot;0&nbsp;15&nbsp;10&nbsp;*&nbsp;*&nbsp;?&nbsp;*&quot;);&nbsp;&nbsp;\r\n//把作业和触发器注册到任务调度中&nbsp;&nbsp;\r\nscheduler.scheduleJob(jobDetail,&nbsp;cornTrigger);&nbsp;&nbsp;\r\n//启动调度&nbsp;&nbsp;\r\nscheduler.start();</pre><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\">CornExpression表达式的具体使用如下：</span></strong></p><pre class=\"brush:plain;toolbar:false\">字段&nbsp;&nbsp;&nbsp;允许值&nbsp;&nbsp;&nbsp;允许的特殊字符&nbsp;&nbsp;&nbsp;&nbsp;\r\n秒&nbsp;&nbsp;&nbsp;&nbsp;0-59&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;-&nbsp;*&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;\r\n分&nbsp;&nbsp;&nbsp;&nbsp;0-59&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;-&nbsp;*&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;\r\n小时&nbsp;&nbsp;&nbsp;&nbsp;0-23&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;-&nbsp;*&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;\r\n日期&nbsp;&nbsp;&nbsp;&nbsp;1-31&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;-&nbsp;*&nbsp;?&nbsp;/&nbsp;L&nbsp;W&nbsp;C&nbsp;&nbsp;&nbsp;&nbsp;\r\n月份&nbsp;&nbsp;&nbsp;&nbsp;1-12&nbsp;或者&nbsp;JAN-DEC&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;-&nbsp;*&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;\r\n星期&nbsp;&nbsp;&nbsp;&nbsp;1-7&nbsp;或者&nbsp;SUN-SAT&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;-&nbsp;*&nbsp;?&nbsp;/&nbsp;L&nbsp;C&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;\r\n年（可选）&nbsp;&nbsp;&nbsp;&nbsp;留空,&nbsp;1970-2099&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;-&nbsp;*&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;\r\n表达式&nbsp;&nbsp;&nbsp;意义&nbsp;&nbsp;&nbsp;&nbsp;\r\n&quot;0&nbsp;0&nbsp;12&nbsp;*&nbsp;*&nbsp;?&quot;&nbsp;&nbsp;&nbsp;&nbsp;每天中午12点触发&nbsp;&nbsp;&nbsp;&nbsp;\r\n&quot;0&nbsp;15&nbsp;10&nbsp;?&nbsp;*&nbsp;*&quot;&nbsp;&nbsp;&nbsp;&nbsp;每天上午10:15触发&nbsp;&nbsp;&nbsp;&nbsp;\r\n&quot;0&nbsp;15&nbsp;10&nbsp;*&nbsp;*&nbsp;?&quot;&nbsp;&nbsp;&nbsp;&nbsp;每天上午10:15触发&nbsp;&nbsp;&nbsp;&nbsp;\r\n&quot;0&nbsp;15&nbsp;10&nbsp;*&nbsp;*&nbsp;?&nbsp;*&quot;&nbsp;&nbsp;&nbsp;&nbsp;每天上午10:15触发&nbsp;&nbsp;&nbsp;&nbsp;\r\n&quot;0&nbsp;15&nbsp;10&nbsp;*&nbsp;*&nbsp;?&nbsp;2005&quot;&nbsp;&nbsp;&nbsp;&nbsp;2005年的每天上午10:15触发&nbsp;&nbsp;&nbsp;&nbsp;\r\n&quot;0&nbsp;*&nbsp;14&nbsp;*&nbsp;*&nbsp;?&quot;&nbsp;&nbsp;&nbsp;&nbsp;在每天下午2点到下午2:59期间的每1分钟触发&nbsp;&nbsp;&nbsp;&nbsp;\r\n&quot;0&nbsp;0/5&nbsp;14&nbsp;*&nbsp;*&nbsp;?&quot;&nbsp;&nbsp;&nbsp;&nbsp;在每天下午2点到下午2:55期间的每5分钟触发&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&quot;0&nbsp;0/5&nbsp;14,18&nbsp;*&nbsp;*&nbsp;?&quot;&nbsp;&nbsp;&nbsp;&nbsp;在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&quot;0&nbsp;0-5&nbsp;14&nbsp;*&nbsp;*&nbsp;?&quot;&nbsp;&nbsp;&nbsp;&nbsp;在每天下午2点到下午2:05期间的每1分钟触发&nbsp;&nbsp;&nbsp;&nbsp;\r\n&quot;0&nbsp;10,44&nbsp;14&nbsp;?&nbsp;3&nbsp;WED&quot;&nbsp;&nbsp;&nbsp;&nbsp;每年三月的星期三的下午2:10和2:44触发&nbsp;&nbsp;&nbsp;&nbsp;\r\n&quot;0&nbsp;15&nbsp;10&nbsp;?&nbsp;*&nbsp;MON-FRI&quot;&nbsp;&nbsp;&nbsp;&nbsp;周一至周五的上午10:15触发&nbsp;&nbsp;&nbsp;&nbsp;\r\n&quot;0&nbsp;15&nbsp;10&nbsp;15&nbsp;*&nbsp;?&quot;&nbsp;&nbsp;&nbsp;&nbsp;每月15日上午10:15触发&nbsp;&nbsp;&nbsp;&nbsp;\r\n&quot;0&nbsp;15&nbsp;10&nbsp;L&nbsp;*&nbsp;?&quot;&nbsp;&nbsp;&nbsp;&nbsp;每月最后一日的上午10:15触发&nbsp;&nbsp;&nbsp;&nbsp;\r\n&quot;0&nbsp;15&nbsp;10&nbsp;?&nbsp;*&nbsp;6L&quot;&nbsp;&nbsp;&nbsp;&nbsp;每月的最后一个星期五上午10:15触发&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&quot;0&nbsp;15&nbsp;10&nbsp;?&nbsp;*&nbsp;6L&nbsp;2002-2005&quot;&nbsp;&nbsp;&nbsp;&nbsp;2002年至2005年的每月的最后一个星期五上午10:15触发&nbsp;&nbsp;&nbsp;&nbsp;\r\n&quot;0&nbsp;15&nbsp;10&nbsp;?&nbsp;*&nbsp;6#3&quot;&nbsp;&nbsp;&nbsp;&nbsp;每月的第三个星期五上午10:15触发&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;\r\n特殊字符&nbsp;&nbsp;&nbsp;意义&nbsp;&nbsp;&nbsp;&nbsp;\r\n*&nbsp;&nbsp;&nbsp;&nbsp;表示所有值；&nbsp;&nbsp;&nbsp;&nbsp;\r\n?&nbsp;&nbsp;&nbsp;&nbsp;表示未说明的值，即不关心它为何值；&nbsp;&nbsp;&nbsp;&nbsp;\r\n-&nbsp;&nbsp;&nbsp;&nbsp;表示一个指定的范围；&nbsp;&nbsp;&nbsp;&nbsp;\r\n,&nbsp;&nbsp;&nbsp;&nbsp;表示附加一个可能值；&nbsp;&nbsp;&nbsp;&nbsp;\r\n/&nbsp;&nbsp;&nbsp;&nbsp;符号前表示开始时间，符号后表示每次递增的值；</pre><div style=\"font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">L(&quot;last&quot;) &nbsp; &nbsp;(&quot;last&quot;) &quot;L&quot;\r\n 用在day-of-month字段意思是 &quot;这个月最后一天&quot;；用在 day-of-week字段, 它简单意思是 &quot;7&quot; or &quot;SAT&quot;。 \r\n如果在day-of-week字段里和数字联合使用，它的意思就是 &quot;这个月的最后一个星期几&quot; – 例如： &quot;6L&quot; means \r\n&quot;这个月的最后一个星期五&quot;. 当我们用“L”时，不指明一个列表值或者范围是很重要的，不然的话，我们会得到一些意想不到的结果。\r\n &nbsp; &nbsp;</span></div><div style=\"font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">W(&quot;weekday&quot;) &nbsp; \r\n&nbsp;只能用在day-of-month字段。用来描叙最接近指定天的工作日（周一到周五）。例如：在day-of-month字段用“15W”指“最接近这个月第15天的工作日”，即如果这个月第15天是周六，那么触发器将会在这个月第14天即周五触发；如果这个月第15天是周日，那么触发器将会在这个月第16天即周一触发；如果这个月第15天是周二，那么就在触发器这天触发。注意一点：这个用法只会在当前月计算值，不会越过当前月。“W”字符仅能在day-of-month指明一天，不能是一个范围或列表。也可以用“LW”来指定这个月的最后一个工作日。\r\n &nbsp; &nbsp;&nbsp;</span></div><div style=\"font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"># &nbsp; &nbsp;只能用在day-of-week字段。用来指定这个月的第几个周几。例：在day-of-week字段用&quot;6#3&quot;指这个月第3个周五（6指周五，3指第3个）。如果指定的日期不存在，触发器就不会触发。 &nbsp; &nbsp;&nbsp;</span></div><div style=\"font-family:Arial; font-size:14px\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">C &nbsp; &nbsp;指和calendar联系后计算过的值。例：在day-of-month 字段用“5C”指在这个月第5天或之后包括calendar的第一天；在day-of-week字段用“1C”指在这周日或之后包括calendar的第一天&nbsp; <br/></span></div><p><br/></p></div><p style=\"line-height: 2em;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"></span></strong><br/></p>',0,'quartz 定时任务 任务调度','Quartz是一个完全由Java编写的开源任务调度框架，为在Java应用程序中进行作业调度提供了简单却强大的机制。它允许开发人员根据时间间隔来调度作业，它实现了作业和触发器的多对多的关系，还能把多个作业与不同的触发器关联。核心概念Quartz的原理不是很复杂，只要搞明白几个概念，然后知道如何去启动和关闭一个调度程序即可。1、Job表示一个工作，要执行的具体内容。此接口中只有一个方法：void ex...',13,36,'20161209/1481266311243.jpg'),(121,'Java中常用的几种设计模式小结','2016-12-10 12:22:49','<p><span style=\"font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">Java中<span style=\"font-family: 微软雅黑,Microsoft YaHei;\">几种</span>常用的设计模式</span></strong></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在Java中使用频率最高的的设计模式主要是：单例模式、工厂模式、适配器模式和代理模式。</span><span style=\"font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><br/></span></strong></span></p><ul style=\"list-style-type: disc;\" class=\" list-paddingleft-2\"><li><p style=\"line-height: 2em;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span><span style=\"font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">单例模式</span></strong></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span></p></li></ul><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">单例模式要达到以下几个目的：</span></p><ol style=\"list-style-type: decimal;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">确保某一个类只有一个实例</span></p></li><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">这个类必须自行实例化并向整个系统提供这个实例</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p></li></ol><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">因此，为了达到以上的几个目的，单例模式必须具有以下几个特点：</span></p><ol style=\"list-style-type: decimal;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">单例类的构造方法为私有</span></p></li><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">提供一个自身的静态私有成员变量</span></p></li><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">提供一个共有的静态工厂方法</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p></li></ol><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">模式结构图如下：</span></p><p><img src=\"/images/20161211/1481387292352020803.png\" title=\"1481387292352020803.png\" alt=\"图片.png\"/></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">单例模式结构图中只包含一个单例角色：</span></p><p><span style=\"font-size: 14px;\">&nbsp;&nbsp;&nbsp;<span style=\"font-size: 14px; color: rgb(255, 0, 0);\">&nbsp;&nbsp; ●</span> <span style=\"font-size: 14px; color: rgb(255, 0, 0);\"><span style=\"font-size: 14px; font-family: Times New Roman;\">Singleton</span>（单例）</span>：在单例类的内部实现只生成一个实例，同时它提供一个静态的<span style=\"font-size: 14px; font-family: Times New Roman;\">getInstance()</span>工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个<span style=\"font-size: 14px; font-family: Times New Roman;\">Singleton</span>类型的静态对象，作为外部共享的唯一实例。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">单例模式的实现方式有很多种，它们各自适用的情况也不尽相同。具体见另一篇文章：<a href=\"/blog/articles/76.shtml\" target=\"_blank\" title=\"Java中的单例模式\">Java中的单例模式</a></span></p><ul style=\"list-style-type: disc;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">工厂模式</span></strong></span></p></li></ul><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">工厂模式是最常用的一类创建型设计模式，工厂模式又可以分为三种：简单工厂模式、工厂方法模式以及<span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">抽象工厂模式</span>。</span></p><p style=\"line-height: 1.75em;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">1、简单工厂模式</span></strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">模式结构图如下：</span></p><p><img alt=\"\" src=\"/ueditor/jsp/upload/image/20161210/1481385209008041327.jpg\" width=\"620\" height=\"300\"/></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在简单工厂模式结构图中包含如下几个角色：</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 18px; font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\"> ●<span style=\"font-size: 18px; font-family: Times New Roman;\"> </span><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei;\">Factory</span>（工厂角色）</span>：</span>工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法<span style=\"font-size: 18px; font-family: Times New Roman;\">factoryMethod()</span>，它的返回类型为抽象产品类型<span style=\"font-size: 18px; font-family: Times New Roman;\">Product</span>。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 18px; font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\">&nbsp;&nbsp; ●<span style=\"font-size: 18px; font-family: Times New Roman;\"> </span><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei;\">Product</span>（抽象产品角色）</span>：</span>它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 18px; font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\"> ●<span style=\"font-size: 18px; font-family: Times New Roman;\"> </span><span style=\"color: rgb(255, 0, 0); font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"color: rgb(255, 0, 0); font-size: 14px;\">ConcreteProduct</span>（具体产品角色）</span></span></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-size: 18px; font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\"><span style=\"color: rgb(255, 0, 0); font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></span><strong><span style=\"font-size: 18px; font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\"><span style=\"color: rgb(255, 0, 0); font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span>：</span></strong>它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用<span style=\"font-size: 18px; font-family: Times New Roman;\">new</span>关键字来创建对象，它是工厂模式家族中最简单的一员。</span></p><p style=\"line-height: 1.75em;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">2、工厂方法模式</span></strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">工厂方法模式又简称为工厂模式<span style=\"font-family: Times New Roman;\">(Factory Pattern)</span>，又可称作虚拟构造器模式<span style=\"font-family: Times New Roman;\">(Virtual Constructor Pattern)</span>或多态工厂模式<span style=\"font-family: Times New Roman;\">(Polymorphic Factory Pattern)</span>。工厂方法模式是一种类创建型模式。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size:18px;\"></span>通常我们所说的工厂模式就是指<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(0, 0, 0);\"><strong>工厂方法模式</strong></span>，它也是<span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">工厂模式</span>中使用频率最高的。模式结构图如下：</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><img alt=\"\" src=\"/ueditor/jsp/upload/image/20161210/1481385382024060667.jpg\" width=\"525\" height=\"335\"/><br/></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">在工厂方法模式结构图中包含如下几个角色：</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">&nbsp;&nbsp;&nbsp;<strong>&nbsp;&nbsp;&nbsp;<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\"> </span></strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">●<span style=\"font-size: 14px; font-family: Times New Roman;\"> Product</span>（抽象产品）：</span>它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ●<span style=\"font-size: 14px; font-family: Times New Roman;\"> ConcreteProduct</span>（具体产品）：</span>它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ●<span style=\"font-size: 14px; font-family: Times New Roman;\"> Factory</span>（抽象工厂）：</span>在抽象工厂类中，声明了工厂方法<span style=\"font-size: 14px; font-family: Times New Roman;\">(Factory Method)</span>，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ●<span style=\"font-size: 14px; font-family: Times New Roman;\"> ConcreteFactory</span>（具体工厂）<strong>：</strong></span>它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</span></p><p style=\"line-height: 1.75em;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-size: 14px; font-family: Times New Roman;\"></span>与简单工厂模式相比，工厂方法模式最重要的区别是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类。<br/></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>3、抽象工厂模式</strong></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为<span style=\"font-family: Times New Roman;\">Kit</span>模式，它是一种对象创建型模式。模式结构图如下：</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span><img alt=\"\" src=\"/ueditor/jsp/upload/image/20161211/1481385855508022683.jpg\" width=\"678\" height=\"564\"/></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">在抽象工厂模式结构图中包含如下几个角色：</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\"> ●<span style=\"font-size: 14px; font-family: Times New Roman;\"> </span></span></strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\"><span style=\"font-size: 14px; font-family: Times New Roman;\">AbstractFactory</span>（抽象工厂）：</span>它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">&nbsp; ●<span style=\"font-size: 14px; font-family: Times New Roman;\"> ConcreteFactory</span>（具体工厂）：</span>它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\"> ●<span style=\"font-size: 14px; font-family: Times New Roman;\"> AbstractProduct</span>（抽象产品）：</span>它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">●<span style=\"font-size: 14px; font-family: Times New Roman;\"> ConcreteProduct</span>（具体产品）</span><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">：</span></strong>它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">在抽象工厂中声明了多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或者具体类。</span></p><ul style=\"list-style-type: disc;\" class=\" list-paddingleft-2\"><li><p style=\"line-height: 2em;\"><span style=\"font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">适配器模式</span></strong></span></p></li></ul><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器<span style=\"font-family: 微软雅黑,Microsoft YaHei;\">(Wrapper)</span>。适配器模式既可以作为类结构型模式（类适配器），也可以作为对象结构型模式（对象适配器）。<span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0); font-size: 14px;\">在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。</span></span></p><p style=\"line-height: 1.75em;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">1、对象适配器</span></strong></p><p style=\"line-height: 1.75em;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在实际开发中，<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">因为<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: Times New Roman;\">Java</span>、<span style=\"font-family: Times New Roman;\">C#</span>等语言不支持多重类继承，因此类适配器的使用受到很多限制</span></span>。所以对象适配器的使用频率更高<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span>。模式结构图如下：</span></p><p style=\"line-height: 1.75em;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><img alt=\"\" src=\"/ueditor/jsp/upload/image/20161211/1481387899539098007.jpg\" width=\"626\" height=\"345\"/></span></strong></p><p style=\"line-height: 1.75em;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在对象适配器模式结构图中包含如下几个角色：</span></p><p><span style=\"font-size: 14px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"font-size: 14px; color: rgb(255, 0, 0);\">●<span style=\"font-size: 14px; font-family: Times New Roman;\"> </span><span style=\"font-size: 14px; font-family: Times New Roman;\">Target</span>（目标抽象类）：</span>目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</span></p><p><span style=\"font-size: 14px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"font-size: 14px; color: rgb(255, 0, 0);\">●</span><span style=\"font-size: 14px; color: rgb(255, 0, 0);\"><span style=\"font-size: 14px; font-family: Times New Roman;\"> Adapter</span>（适配器类）：</span>适配器可以调用另一个接口，作为一个转换器，对<span style=\"font-size: 14px; font-family: Times New Roman;\">Adaptee</span>和<span style=\"font-size: 14px; font-family: Times New Roman;\">Target</span>进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承<span style=\"font-size: 14px; font-family: Times New Roman;\">Target</span>并关联一个<span style=\"font-size: 14px; font-family: Times New Roman;\">Adaptee</span>对象使二者产生联系。</span></p><p style=\"line-height: 1.75em;\"><span style=\"font-size: 14px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"font-size: 14px; color: rgb(255, 0, 0);\">●<span style=\"font-size: 14px; font-family: Times New Roman;\"> </span></span><span style=\"font-family: Times New Roman; font-size: 14px; color: rgb(255, 0, 0);\">Adaptee</span><span style=\"font-size: 14px; color: rgb(255, 0, 0);\">（适配者类）：</span>适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</span><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span></strong><br/></p><p style=\"line-height: 1.75em;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">2、类适配器</span></strong></p><p style=\"line-height: 1.75em;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(0, 0, 0);\">类适配器与对象适配器最大的区别在于：在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。模式结构图如下：</span></p><p style=\"line-height: 1.75em;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><img alt=\"\" src=\"/ueditor/jsp/upload/image/20161211/1481388039836096806.jpg\" width=\"640\" height=\"382\"/></span></strong><br/></p><p style=\"line-height: 1.75em;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在类适配器模式结构图中包含如下几个角色：</span></p><p><span style=\"font-size: 14px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"font-size: 14px; color: rgb(255, 0, 0);\">●<span style=\"font-size: 14px; font-family: Times New Roman;\"> </span><span style=\"font-size: 14px; font-family: Times New Roman;\">Target</span>（目标抽象类）：</span>目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</span></p><p><span style=\"font-size: 14px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"font-size: 14px; color: rgb(255, 0, 0);\">●<span style=\"font-size: 14px; font-family: Times New Roman;\"> </span><span style=\"font-size: 14px; font-family: Times New Roman;\">Adapter</span>（适配器类）：</span>适配器可以调用另一个接口，作为一个转换器，对<span style=\"font-size: 14px; font-family: Times New Roman;\">Adaptee</span>和<span style=\"font-size: 14px; font-family: Times New Roman;\">Target</span>进行适配，适配器类是适配器模式的核心，在类适配器中，它通过实现<span style=\"font-size: 14px; font-family: Times New Roman;\">Target</span>并继承一个<span style=\"font-size: 14px; font-family: Times New Roman;\">Adaptee</span>类使二者产生联系。</span></p><p><span style=\"font-size: 14px;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style=\"font-size: 14px; color: rgb(255, 0, 0);\">●<span style=\"font-size: 14px; font-family: Times New Roman;\"> </span></span><span style=\"font-family: Times New Roman; font-size: 14px; color: rgb(255, 0, 0);\">Adaptee</span><span style=\"font-size: 14px; color: rgb(255, 0, 0);\">（适配者类）：</span>适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</span></p><ul style=\"list-style-type: disc;\" class=\" list-paddingleft-2\"><li><p style=\"line-height: 2em;\"><span style=\"font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">代理模式</span></strong></span></p></li></ul><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。代理模式是一种对象结构型模式。模式结构图如下：</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><img src=\"/ueditor/jsp/upload/image/20161211/1481388619883031170.jpg\" alt=\"http://img.my.csdn.net/uploads/201211/26/1353942400_6301.jpg\" width=\"527\" height=\"373\"/><br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">代理模式包含如下三个角色：</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong><span style=\"font-size: 18px; font-family: Times New Roman;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 18px; font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\">&nbsp; </span></span></strong><span style=\"font-size: 18px; font-family: Times New Roman;\"><span style=\"font-size: 18px; font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\"><span style=\"font-size: 14px;\"><span style=\"font-size: 14px; color: rgb(255, 0, 0);\">●<span style=\"font-size: 14px; font-family: Times New Roman;\"> </span></span></span></span></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\">Subject</span><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\">（抽象主题角色）</span></span><span style=\"font-size: 18px; font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\">：</span>它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-size: 18px; font-family: Times New Roman;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 18px; font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\"> </span></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\"><span style=\"font-size: 14px;\"><span style=\"font-size: 14px; color: rgb(255, 0, 0);\">●<span style=\"font-size: 14px; font-family: Times New Roman;\"> </span></span></span>Proxy</span><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\">（代理主题角色）</span></span><span style=\"font-size: 18px; font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\">：</span>它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-size: 18px; font-family: Times New Roman;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style=\"font-size: 18px; font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\">&nbsp; <span style=\"font-size: 14px;\"><span style=\"font-size: 14px; color: rgb(255, 0, 0);\">●<span style=\"font-size: 14px; font-family: Times New Roman;\"> </span></span></span></span></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\">RealSubject</span><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\">（真实主题角色）</span></span><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\"></span></span><span style=\"font-size: 18px; font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\">：</span></strong>它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</span></p><p><br/></p>',0,'设计模式 Java 面向对象','Java中几种常用的设计模式在Java中使用频率最高的的设计模式主要是：单例模式、工厂模式、适配器模式和代理模式。单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。单例模式要达到以下几个目的：确保某一个类只有一个实例这个类必须自行实例化并向整个系统提供这个实例因此，为了达到以上的几个目的，单例模式必须具有...',16,18,'20161210/1481343769586.jpg'),(122,'设计模式小结','2016-12-11 00:23:20','<p style=\"line-height: 2em;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在学习设计模式之前，我们有必要先学习面向对象的几大设计原则</span><span style=\"font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">，</span><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">因为模式是原则的具体体现。</span></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 18px;\"><strong><br/></strong></span></p><p style=\"line-height: 2em;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 18px;\"><strong>面向对象七大设计原则</strong></span></p><p style=\"line-height: normal;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">如何同时提高一个软件系统的<strong>可维护性和可复用性</strong>是面向对象设计需要解决的核心问题之一。<br/></span></p><p style=\"line-height: normal;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">面向对象设计原则为支持可维护性复用而诞生</span></strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。</span></p><p style=\"line-height: 2em;\"><span style=\"font-size: 14px;\">七种面向对象设计原则如下表所示：</span></p><p style=\"line-height: 2em;\"><span style=\"font-size: 14px;\"></span></p><table><tbody><tr class=\"firstRow\"><td style=\"background: rgb(243, 243, 243) none repeat scroll 0% 0%; word-break: break-all;\" valign=\"top\"><strong><span style=\"font-size: 16px;\">设计原则名称</span></strong></td><td style=\"background: rgb(243, 243, 243);\" valign=\"top\"><p><span style=\"font-size: 16px;\"><strong>定<span style=\"font-family:Times New Roman;\">&nbsp;&nbsp;</span>义</strong></span></p></td><td style=\"background: rgb(243, 243, 243);\" valign=\"top\"><p><strong><span style=\"font-size: 16px;\">使用频率</span></strong></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">单一职责原则</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">(Single Responsibility Principle, SRP)</span></p></td><td style=\"word-break: break-all;\" valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">一个类只负责一个功能领域中的相应职责</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">（<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">类的职责单一化</span>）<br/></span></p></td><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★☆</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">开闭原则</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">(Open-Closed Principle, OCP)</span></p></td><td style=\"word-break: break-all;\" valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">软件实体应对扩展开放，而对修改关闭</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">（<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">对扩展开放，对修改关闭</span>）<br/></span></p></td><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★★</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">里氏代换原则</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">(Liskov Substitution Principle, LSP)</span></p></td><td style=\"word-break: break-all;\" valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">所有引用基类对象的地方能够透明地使用其子类的对象</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">（<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">针对基类编程，使用抽象类或接口</span>）</span></p></td><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★★</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">依赖倒转原则</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">(Dependence&nbsp; Inversion Principle, DIP)</span></p></td><td style=\"word-break: break-all;\" valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">抽象不应该依赖于细节，细节应该依赖于抽象</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">（<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">针对接口编程</span>）<br/></span></p></td><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★★</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">接口隔离原则</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">(Interface Segregation Principle, ISP)</span></p></td><td style=\"word-break: break-all;\" valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">使用多个专门的接口，而不使用单一的总接口</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">（<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">接口的职责单一化</span>）<br/></span></p></td><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★☆☆☆</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">合成复用原则</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">(Composite Reuse Principle, CRP)</span></p></td><td style=\"word-break: break-all;\" valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">尽量使用对象组合，而不是继承来达到复用的目的</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">（<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">多用组合，少用继承</span>）<br/></span></p></td><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★☆</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">迪米特法则</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">(Law of Demeter, LoD)</span></p></td><td style=\"word-break: break-all;\" valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">一个软件实体应当尽可能少地与其他实体发生相互作用</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">（<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">”<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">不</span>与陌生人说话“</span>）<br/></span></p></td><td style=\"word-break: break-all;\" valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★☆☆</span></p></td></tr></tbody></table><p style=\"line-height: 2em;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 18px;\"><strong>设计模式</strong></span></p><p><strong><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">设计模式</span></strong><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><span style=\"font-family: Times New Roman;\">(Design Pattern)</span>是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。<br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">设计模式一般包含模式名称、问题、目的、解决方案、效果等组成要素，其中关键要素是模式名称、问题、解决方案和效果。</span></p><p style=\"line-height: 1.75em;\"><span style=\"font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">分类</span></strong></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></strong></p><p style=\"line-height: 1.75em;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">1. 按照目的：</span></strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span></p><ul style=\"list-style-type: disc;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>创建型</strong>（负责对象创建），共<strong>五种</strong>：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</span></p></li><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>结构型</strong>（处理类与对象之间的组合），共<strong>七种</strong>：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</span></p></li><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>行为型</strong>（类与对象交互中的职责分配），共<strong>十一种</strong>：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span><br/></p></li></ul><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">如下表所示：</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 18px;\"><br/></span></strong></span></p><table align=\"center\"><tbody><tr class=\"firstRow\"><td style=\"background: rgb(242, 242, 242) none repeat scroll 0% 0%; word-break: break-all;\" valign=\"top\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\"><strong>模式类型</strong></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></td><td style=\"background: rgb(242, 242, 242) none repeat scroll 0% 0%; word-break: break-all;\" valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">模式名称</span></strong></span></p></td><td style=\"BACKGROUND: rgb(242,242,242)\" valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">学习难度</span></strong></span></p></td><td style=\"BACKGROUND: rgb(242,242,242)\" valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">使用频率</span></strong></span></p></td></tr><tr><td rowspan=\"6\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">创建型模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Creational Pattern</span></p></td><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">单例模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Singleton Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★☆☆☆☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★☆</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">简单工厂模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Simple Factory Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★☆☆☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★☆☆</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">工厂方法模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Factory Method Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★☆☆☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★★</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">抽象工厂模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Abstract&nbsp; Factory Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★★</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">原型模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Prototype Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★☆☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★☆☆</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">建造者模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Builder Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★☆☆☆</span></p></td></tr><tr><td rowspan=\"7\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">结构型模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Structural Pattern</span></p></td><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">适配器模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Adapter Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★☆☆☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★☆</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">桥接模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Bridge&nbsp; Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★☆☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★☆☆</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">组合模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Composite&nbsp; Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★☆☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★☆</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">装饰模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Decorator&nbsp; Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★☆☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★☆☆</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">外观模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Façade&nbsp; Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★☆☆☆☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★★</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">享元模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Flyweight&nbsp; Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★☆☆☆☆</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">代理模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Proxy&nbsp; Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★☆☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★☆</span></p></td></tr><tr><td rowspan=\"11\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">行为型模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Behavioral Pattern</span></p></td><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">职责链模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Chain&nbsp; of Responsibility Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★☆☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★☆☆☆</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">命令模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Command&nbsp; Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★☆☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★☆</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">解释器模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Interpreter&nbsp; Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★★</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★☆☆☆☆</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">迭代器模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Iterator&nbsp; Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★☆☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★★</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">中介者模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Mediator&nbsp; Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★☆☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★☆☆☆</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">备忘录模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Memento&nbsp; Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★☆☆☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★☆☆☆</span></p></td></tr><tr><td style=\"word-break: break-all;\" valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">观察者模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Observer&nbsp; Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★☆☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★★</span></p></td></tr><tr><td style=\"word-break: break-all;\" valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">状态模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">State&nbsp; Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★☆☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★☆☆</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">策略模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Strategy&nbsp; Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★☆☆☆☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★☆</span></p></td></tr><tr><td valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">模板方法模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Template&nbsp; Method Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★☆☆☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★☆☆</span></p></td></tr><tr><td style=\"word-break: break-all;\" valign=\"top\"><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">访问者模式</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Visitor&nbsp; Pattern</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★★★★☆</span></p></td><td valign=\"top\"><p><span style=\"color: rgb(255, 0, 0); font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">★☆☆☆☆</span></p></td></tr></tbody></table><p><span style=\"font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"></span></strong></span></p><p style=\"line-height: 1.75em;\"><span style=\"font-size: 14px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">2. 按照范围：</span></strong></span></p><ul style=\"list-style-type: disc;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">类模式：处理类与类间的静态关系</span></p></li><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">对象模式：处理对象间的动态关系</span></p></li></ul><p><br/></p>',0,'设计模式 面向对象','在学习设计模式之前，我们有必要先学习面向对象的几大设计原则，因为模式是原则的具体体现。面向对象七大设计原则如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。七种面向对象设计原则如下表所示：设计原则名称定  义使用频率单一职责原则(Single Respo...',14,18,'20161211/1481387000211.jpg'),(123,'Spring整合Quartz简单示例','2016-12-12 00:35:29','<p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在Spring中使用Quartz有两种方式实现：第一种是任务类继承QuartzJobBean，第二种则是在配置文件里定义任务类和要执行的方法，类和方法仍然是普通类。很显然，第二种方式远比第一种方式来的灵活。下面我们就介绍第二种方式：<br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">当然首先需要导入<span style=\"font-size: small;\">quartz-1.8.5.jar、commons-logging.jar两个jar包。</span></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">1、自定义Job，即要执行的任务：</span></p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.xjc.quartz.job;&nbsp;&nbsp;\r\n/**&nbsp;\r\n&nbsp;*&nbsp;Job类不需要继承org.springframework.scheduling.quartz.QuartzJobBean类，每隔指定时间则触发一次&nbsp;\r\n&nbsp;*/&nbsp;&nbsp;\r\npublic&nbsp;class&nbsp;MyJob&nbsp;{&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;int&nbsp;i&nbsp;=&nbsp;0;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;doJob()&nbsp;{&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;任务第&quot;&nbsp;+&nbsp;++i&nbsp;+&nbsp;&quot;次调度...&quot;);&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;\r\n&nbsp;&nbsp;\r\n}</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">2、在Spring的applicationContext.xml文件中配置Quartz的Bean，包括Job、JobDetail工厂（MethodInvokingJobDetailFactoryBean）、Trigger（SimpleTriggerBean或者CronTriggerBean）以及Scheduler工厂（SchedulerFactoryBean），如下：</span></p><pre class=\"brush:xml;toolbar:false\">&lt;?xml&nbsp;version=&quot;1.0&quot;&nbsp;encoding=&quot;UTF-8&quot;?&gt;&nbsp;&nbsp;\r\n&lt;beans&nbsp;xmlns=&quot;http://www.springframework.org/schema/beans&quot;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:context=&quot;http://www.springframework.org/schema/context&quot;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.springframework.org/schema/beans/spring-beans-4.2.xsd&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.springframework.org/schema/context&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.springframework.org/schema/context/spring-context-4.2.xsd&quot;&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;任务&nbsp;--&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean&nbsp;id=&quot;myJob&quot;&nbsp;class=&quot;com.xjc.quartz.job.MyJob&quot;/&gt;\r\n&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;任务详情&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean&nbsp;id=&quot;myJobDetail&quot;&nbsp;class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;调用的目标任务(作业)&nbsp;&nbsp;&nbsp;--&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;targetObject&quot;&nbsp;ref=&quot;myJob&quot;/&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;调用的目标(作业)方法,它是真正执行任务的内容&nbsp;&nbsp;--&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;targetMethod&quot;&nbsp;value=&quot;doJob&quot;&nbsp;/&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;不并发调度&nbsp;--&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;concurrent&quot;&nbsp;value=&quot;false&quot;&nbsp;/&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;配置作业调度的触发方式&nbsp;2种触发方式--&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;1：每隔指定时间则调度任务&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean&nbsp;id=&quot;simpleTrigger&quot;&nbsp;class=&quot;org.springframework.scheduling.quartz.SimpleTriggerBean&quot;&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;jobDetail&quot;&nbsp;ref=&quot;myJobDetail&quot;&nbsp;/&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;startDelay&quot;&nbsp;value=&quot;0&quot;&nbsp;/&gt;&lt;!--&nbsp;调度工厂实例化后，经过0秒开始执行调度&nbsp;--&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;repeatInterval&quot;&nbsp;value=&quot;2000&quot;&nbsp;/&gt;&lt;!--&nbsp;每2秒调度一次&nbsp;--&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;2：每到指定时间就调度任务&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean&nbsp;id=&quot;cronTrigger&quot;&nbsp;class=&quot;org.springframework.scheduling.quartz.CronTriggerBean&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;jobDetail&quot;&nbsp;ref=&quot;myJobDetail&quot;&nbsp;/&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;每到指定的时间就调度一次&nbsp;--&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;cronExpression&quot;&nbsp;value=&quot;0&nbsp;0/1&nbsp;*&nbsp;*&nbsp;*&nbsp;?&quot;&nbsp;/&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;\r\n&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;配置调度工厂，由Spring负责创建Scheduler对象&nbsp;--&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean&nbsp;class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;triggers&quot;&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;list&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;&lt;ref&nbsp;bean=&quot;simpleTrigger&quot;&nbsp;/&gt;&nbsp;--&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;ref&nbsp;bean=&quot;cronTrigger&quot;&nbsp;/&gt;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/list&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;&nbsp;&nbsp;\r\n&lt;/beans&gt;</pre><p><br/></p><p><br/></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span><br/></p>',0,'quartz 定时任务','在Spring中使用Quartz有两种方式实现：第一种是任务类继承QuartzJobBean，第二种则是在配置文件里定义任务类和要执行的方法，类和方法仍然是普通类。很显然，第二种方式远比第一种方式来的灵活。下面我们就介绍第二种方式：当然首先需要导入quartz-1.8.5.jar、commons-logging.jar两个jar包。1、自定义Job，即要执行的任务：package com.xjc....',5,36,'20161212/1481474250006.jpg'),(124,'处理流与节点流','2016-12-12 11:33:43','<p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在Java中，IO流按照流是否直接与特定的地方(如磁盘、内存、设备等)相连，分为节点流和处理流两种。</span></p><p><span style=\"font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">节点流</span></strong></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">它可以从或向一个特定的地方（节点）读写数据。如FileReader 。</span></p><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">直接操作目标设备</span></strong><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">(如磁盘、内存、设备等)</span></span></strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span>所对应的类叫做节点流类，节点流类所对应的IO源或者目标称为流节点。譬如，我们用一个类和某个文件根网络直接相关联，这个类就叫做节点流类，这个文件、网络就叫做流的节点。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">常用的节点流如下：</span><br/><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p><pre class=\"best-text mb-10\" style=\"min-height: 55px;\"><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">文 件：对文件进行处理的节点流。如FileInputStream FileOutputStrean FileReader FileWriter <br/>字符串：对字符串进行处理的节点流。如 StringReader StringWriter <br/>数 组：对数组进行处理的节点流(对应的不再是文件，而是内存中的一个数组)。如</span><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">Byte</span><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">ArrayInputStream </span><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">Byte</span><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">ArrayOutputStreamCharArrayReader CharArrayWriter <br/>管 道：对管道进行处理的节点流。如PipedInputStream PipedOutputStream PipedReaderPipedWriter</span></pre><p><span style=\"font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">处理流</span></strong></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">处理流是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。 <br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">程序也可以<strong>通过间接的流类去调用这个节点流类</strong>，以达到更加灵活方便地读取各种类型的数据。譬如，我们要通过网络传输对象，我们就可以设计一种叫做对象流的这种类，但实际上是要调用底层的网络流类，所以它叫包装类</span></span>。</p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">常用的处理流如下：</span><br/></p><pre class=\"best-text mb-10\" style=\"min-height: 55px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">缓冲流：增加缓冲功能，避免频繁读写硬盘。如BufferedInputStrean BufferedOutputStream BufferedReader BufferedWriter </span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/>转换流：实现字节流和字符流之间的转换。如InputStreamReader OutputStreamReader</span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/>数据流：DataInputStream DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来。</span></pre><p><strong>补充</strong><strong>：</strong></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">缓冲流为什么比不带缓冲的流性能高？</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">这是因为缓冲流在内存中开辟了一块空间作为缓冲区，当读或写文件时程序会先将数据读到缓冲区中，待缓冲区满了后再从缓冲区读数据，这就比不用缓冲区效率更高了。比如你现在要往一个文件里写，你如果不用缓冲流，就要频繁的打开文件流，这样非常耗时，所以使用缓冲流可以缓解。就比如，你要去学校的开水房打水，如果你去一杯一杯的打开水也可以，如果想快就提一个电壶过去打一壶(缓冲流）。可想而知，<strong>缓冲流明显减少了程序访问文件的次数，从而提高了效率</strong>。</span>\r\n &nbsp; &nbsp; &nbsp;&nbsp; <br/></p>',0,'IO 流 缓冲','在Java中，IO流按照流是否直接与特定的地方(如磁盘、内存、设备等)相连，分为节点流和处理流两种。节点流它可以从或向一个特定的地方（节点）读写数据。如FileReader 。直接操作目标设备(如磁盘、内存、设备等)所对应的类叫做节点流类，节点流类所对应的IO源或者目标称为流节点。譬如，我们用一个类和某个文件根网络直接相关联，这个类就叫做节点流类，这个文件、网络就叫做流的节点。常用的节点流如下：文...',6,38,'20161212/1481513623225.jpg'),(125,'Java中实现排序的两种方式──Comparable和Comparator','2016-12-17 00:37:09','<p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在Java中，提供了两种排序的方式：Comparable 和 ComParator 。</span></p><p style=\"line-height: 2em;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\"><strong>Comparable</strong></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">即自然排序。Comparable 位于 java.lang 包下，它是一个接口，接口内部只有一个 compareTo() 方法：</span></p><pre class=\"brush:java;toolbar:false\">public&nbsp;interface&nbsp;Comparable&lt;T&gt;&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;compareTo(T&nbsp;o);\r\n}</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Comparable 可以让实现它的类的对象进行比较，具体的比较规则是按照 compareTo 方法中定义的规则进行，这种顺序称为 自然顺序 。<br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">若要让自己定义的类实现排序功能，则需要该类实现 Comparable 接口，并重写其 compareTo 方法。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">compareTo 方法的返回值有以下三种情况：</span></p><ul style=\"list-style-type: disc;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">e1.compareTo(e2) 的返回值 &gt; 0，即 e1 &gt; e2</span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">e1.compareTo(e2) 的返回值 = 0，即 e1 = e2</span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">e1.compareTo(e2) 的返回值 &lt; 0，即 e1 &lt; e2</span></p></li></ul><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Comparable 接口是 Java 集合框架的一部分。<br/></span></p><p style=\"line-height: 2em;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\"><strong>Comparator</strong></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">即自定义排序。Comparator在 java.util 包下，它也是一个接口， JDK 1.8 以前只包含两个方法：</span></p><pre class=\"brush:java;toolbar:false\">public&nbsp;interface&nbsp;Comparator&lt;T&gt;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;compare(T&nbsp;o1,&nbsp;T&nbsp;o2);\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;equals(Object&nbsp;obj);\r\n}</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Comparator 是在外部定义排序规则，然后作为排序策略参数传递给某些类，比如 Collections.sort()，Arrays.sort()，或者一些内部有序的集合（比如 SortedSet，SortedMap 等）。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">它的使用方式主要分为以下三步：</span></p><ol style=\"list-style-type: decimal;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">创建一个 Comparator 接口的实现类，并赋值给一个对象，在 compare 方法中针对自定义类编写排序规则</span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">将 Comparator 对象作为参数传递给排序类的某个方法</span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">向排序类中添加 compare 方法使用的自定义类</span></p></li></ol><p>如下例子：</p><pre class=\"brush:java;toolbar:false\">//&nbsp;1、创建一个&nbsp;Comparator&nbsp;接口的对象\r\nComparator&nbsp;comparator&nbsp;=&nbsp;new&nbsp;Comparator(){\r\n&nbsp;&nbsp;@Override\r\n&nbsp;&nbsp;public&nbsp;int&nbsp;compare(Object&nbsp;o1,Object&nbsp;o2){\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;这里写具体的排序规则\r\n&nbsp;&nbsp;}&nbsp;&nbsp;\r\n};\r\n\r\n//&nbsp;2、将&nbsp;Comparator&nbsp;对象传递到&nbsp;TreeSet&nbsp;的构造方法中\r\nTreeSet&nbsp;treeSet&nbsp;=&nbsp;new&nbsp;TreeSet(comparator);\r\n\r\n//&nbsp;3、向&nbsp;TreeSet&nbsp;中添加自定义类的对象\r\ntreeSet.add(new&nbsp;Book(&#39;Java&#39;,20));\r\ntreeSet.add(new&nbsp;Book(&#39;C#&#39;,10));</pre><p style=\"line-height: normal;\"><span style=\"font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">总结</span></strong></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Java中的两种排序方式：</span></p><ol style=\"list-style-type: decimal;\" class=\" list-paddingleft-2\"><li><p style=\"line-height: normal;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Comparable 自然排序 （实体类实现）</span></p></li><li><p style=\"line-height: normal;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Comparator 自定义排序 （当无法修改实体类时，直接在调用方创建）</span></p></li></ol><p style=\"line-height: normal;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">当两种排序同时存在时，则会采用 Comparator 的规则进行比较。</span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/></span></p><p style=\"line-height: normal;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">对于一些普通的数据类型（比如 String、Double、Integer等），它们都默认实现了 Comparable 接口，并重写了 compareTo 方法，因此我们可以直接使用。</span></p><p style=\"line-height: normal;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">而对于自定义类，它们可能在不同的情况下需要采用不同的比较策略。因此，我们可以通过创建不同的 Comparator 实现类来进行比较。<br/></span></p>',0,'排序 Comparator Comparable','在Java中，提供了两种排序的方式：Comparable 和 ComParator 。Comparable即自然排序。Comparable 位于 java.lang 包下，它是一个接口，接口内部只有一个 compareTo() 方法：public interface Comparable<T> {    public int compareTo(T o);}Comparable 可以让实现它的类的...',11,10,'20161217/1481906229537.jpg'),(126,'AngularJS基础','2016-12-20 00:41:08','<p style=\"line-height: 2em;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><strong>AngularJS 简介</strong></span></p><p class=\"intro\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">AngularJS 是一个 <strong>JavaScript 框架</strong>。它可通过 &lt;script&gt; 标签添加到 HTML 页面。</span></p><p class=\"intro\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">它通过 <strong>指令</strong> 扩展了 HTML，且通过 <strong>表达式</strong> 绑定数据到 HTML。</span></p><p style=\"line-height: 2em;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">AngularJS 表达式</span></strong></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">语法：<strong>{{ expression }}</strong>。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">AngularJS 表达式把数据绑定到 HTML，这与 <strong>ng-bind</strong> 指令有异曲同工之妙。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">AngularJS 将在表达式书写的位置&quot;输出&quot;数据。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">AngularJS 表达式 很像 JavaScript \r\n表达式：它们可以包含文字、运算符和变量。如下：</span></p><pre class=\"brush:html;toolbar:false\">&lt;div&nbsp;ng-app=&quot;&quot;&nbsp;ng-init=&quot;firstName=&#39;John&#39;;lastName=&#39;Doe&#39;&quot;&gt;\r\n&nbsp;&lt;p&gt;姓名：&nbsp;{{&nbsp;firstName&nbsp;+&nbsp;&quot;&nbsp;&quot;&nbsp;+&nbsp;lastName&nbsp;}}&lt;/p&gt;\r\n&nbsp;&lt;/div&gt;</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">使用 ng-bind 指令的相同实例：</span><br/></p><pre class=\"brush:html;toolbar:false\">&lt;div&nbsp;ng-app=&quot;&quot;&nbsp;ng-init=&quot;quantity=1;cost=5&quot;&gt;\r\n&nbsp;&lt;p&gt;总价：&nbsp;&lt;span&nbsp;ng-bind=&quot;quantity&nbsp;*&nbsp;cost&quot;&gt;&lt;/span&gt;&lt;/p&gt;\r\n&nbsp;&lt;/div&gt;</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">AngularJS 表达式 与 JavaScript 表达式的比较：</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">类似于 JavaScript 表达式，<strong>AngularJS 表达式可以包含字母，操作符，变量</strong>。<br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">与 JavaScript 表达式不同，<strong>AngularJS 表达式可以写在 HTML 中。</strong></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">与 JavaScript 表达式不同，<strong>AngularJS 表达式不支持条件判断，循环及异常。</strong></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">与 JavaScript 表达式不同，<strong>AngularJS 表达式支持过滤器。</strong></span></p><p style=\"line-height: 2em;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;\">AngularJS 指令</span></strong></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">AngularJS 指令是扩展的 HTML 属性，带有前缀 <strong>ng-</strong>。</span></p><ul style=\"list-style-type: disc;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>ng-app</strong> 指令初始化一个 AngularJS 应用程序，它定义了 AngularJS 应用程序的 根元素。ng-app 指令在<strong>网页加载完毕时</strong>会自动引导（自动初始化）应用程序。</span></p></li><li><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">ng-init </span></strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">指令为 AngularJS 应用程序定义了 初始值。通常情况下，不使用 ng-init。而是使用一个控制器或模块来代替它。</span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>ng-model</strong> 指令把HTML元素值（比如输入域的值）绑定到应用程序。<strong>绑定 HTML 元素到应用程序数据。</strong></span></p></li><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>ng-bind </strong>指令绑定 HTML 元素到应用程序数据。</span></p></li><li><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">ng-repeat</span></strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> 指令会重复一个 HTML 元素，该指令对于集合中（或数组中）的每个项会 <strong>克隆一次 HTML 元素</strong>。类似于foreach，用于遍历集合或数组。如下所示：</span></p></li></ul><pre class=\"brush:html;toolbar:false\">&lt;div&nbsp;ng-app=&quot;&quot;&nbsp;ng-init=&quot;names=[\r\n{name:&#39;Jani&#39;,country:&#39;Norway&#39;},\r\n{name:&#39;Hege&#39;,country:&#39;Sweden&#39;},\r\n{name:&#39;Kai&#39;,country:&#39;Denmark&#39;}]&quot;&gt;\r\n&nbsp;&lt;p&gt;循环对象：&lt;/p&gt;&lt;ul&gt;\r\n&nbsp;&nbsp;&lt;li&nbsp;ng-repeat=&quot;x&nbsp;in&nbsp;names&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;{{&nbsp;x.name&nbsp;+&nbsp;&#39;,&nbsp;&#39;&nbsp;+&nbsp;x.country&nbsp;}}&nbsp;&nbsp;&lt;/li&gt;&lt;/ul&gt;\r\n&nbsp;&lt;/div&gt;</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">此外，常用的内置指令还有<strong>ng-click</strong>（点击事件）<strong>、ng-if</strong>（判断）<strong>、ng-hide</strong> 和 <strong>ng-show</strong>（指定HTML元素是否可见，<span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">取值为true或false</span>）等。</span><br/></p><ul style=\"list-style-type: disc;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">除了 AngularJS 内置的指令外，我们还可以创建<strong>自定义指令</strong>。可以<strong>使用 .directive 函数</strong>来添加自定义的指令。</span></p></li></ul><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">要调用自定义指令，HTML 元素上需要添加自定义指令名。如下：</span></p><pre class=\"brush:html;toolbar:false\">&lt;body&nbsp;ng-app=&quot;myApp&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;custom-directive&gt;&lt;/custom-directive&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;script&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;app&nbsp;=&nbsp;angular.module(&quot;myApp&quot;,&nbsp;[]);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;app.directive(&quot;customDirective&quot;,&nbsp;function()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;{&nbsp;\r\n	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;template&nbsp;:&nbsp;&quot;&lt;h1&gt;自定义指令!&lt;/h1&gt;&quot;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};\r\n	});\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/script&gt;\r\n&lt;/body&gt;</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">通过添加 <strong>restrict </strong>属性，\r\n	来限制指令只能通过特定的方式来调用。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">restrict 值可以是以下几种:</span></p><ul class=\" list-paddingleft-2\"><li><p><code><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">E</span></code><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> 作为元素名使用</span></p></li><li><p><code><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">A</span></code><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> 作为属性使用</span></p></li><li><p><code><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">C</span></code><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> 作为类名使用</span></p></li><li><p><code><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">M</span></code><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> 作为注释使用</span></p></li></ul><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">restrict 默认值为 </span><code><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">EA</span></code><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">, 即可以通过元素名和属性名来调用指令。</span></strong></p><p style=\"line-height: 2em;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"><strong>AngularJS Scope（作用域）</strong></span></p><ul style=\"list-style-type: disc;\" class=\" list-paddingleft-2\"><li><p style=\"line-height: normal;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">scope(作用域) <br/></span></strong></p></li></ul><p style=\"line-height: normal;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Scope </span></strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">是应用在 HTML (视图) 和 JavaScript (控制器)之间的纽带。</span></p><p style=\"line-height: normal;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">它是一个 JavaScript 对象，带有属性和方法，这些属性和方法可以在视图和控制器中使用。</span></p><p style=\"line-height: normal;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">当在 AngularJS 创建控制器时，我们可以将 <strong>$scope</strong> 对象当作一个参数传递。控制器中的属性对应了视图上的属性，如下：</span></p><pre class=\"brush:html;toolbar:false\">&lt;div&nbsp;ng-app=&quot;myApp&quot;&nbsp;ng-controller=&quot;myCtrl&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;{{carname}}&lt;/h1&gt;\r\n&lt;/div&gt;\r\n&lt;script&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;app&nbsp;=&nbsp;angular.module(&#39;myApp&#39;,&nbsp;[]);\r\n&nbsp;&nbsp;&nbsp;&nbsp;app.controller(&#39;myCtrl&#39;,&nbsp;function($scope)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scope.carname&nbsp;=&nbsp;&quot;Volvo&quot;;\r\n&nbsp;&nbsp;&nbsp;&nbsp;});\r\n&lt;/script&gt;</pre><p style=\"line-height: normal;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span></p><ul style=\"list-style-type: disc;\" class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>rootScope 根作用域</strong></span></p></li></ul><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">所有的应用都有一个 <strong>$rootScope</strong>，它可以作用在 <strong>ng-app</strong> 指令包含的所有 HTML 元素中。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>$rootScope</strong> 可作用于整个应用中。是各个 controller 中 scope 的桥梁。用 rootscope 定义的值，可以在各个 controller 中使用。</span></p><p style=\"line-height: normal;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">同样的，创建控制器时，将 $rootScope 作为参数传递，可在应用中使用：</span></p><pre class=\"brush:html;toolbar:false\">&lt;div&nbsp;ng-app=&quot;myApp&quot;&nbsp;ng-controller=&quot;myCtrl&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;{{lastname}}&nbsp;家族成员:&lt;/h1&gt;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;ul&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;li&nbsp;ng-repeat=&quot;x&nbsp;in&nbsp;names&quot;&gt;{{x}}&nbsp;\r\n	{{lastname}}&lt;/li&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/ul&gt;\r\n&lt;/div&gt;\r\n&lt;script&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;app&nbsp;=&nbsp;angular.module(&#39;myApp&#39;,&nbsp;[]);\r\n&nbsp;&nbsp;&nbsp;&nbsp;app.controller(&#39;myCtrl&#39;,&nbsp;function($scope,&nbsp;$rootScope)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scope.names&nbsp;=&nbsp;[&quot;Emil&quot;,&nbsp;&quot;Tobias&quot;,&nbsp;&quot;Linus&quot;];\r\n&nbsp;&nbsp;&nbsp;&nbsp;\r\n	$rootScope.lastname&nbsp;=&nbsp;&quot;Refsnes&quot;;\r\n});\r\n&lt;/script&gt;</pre><p style=\"line-height: 2em;\"><span style=\"font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">AngularJS Controller（控制器）</span></strong></span></p><p style=\"line-height: 2em;\"><span style=\"font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\"></span></strong></span></p><p style=\"line-height: normal;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">ng-controller</span></strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"> 指令定义了应用程序控制器。</span></p><p style=\"line-height: normal;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">控制器是一个 JavaScript 对象，由标准的 JavaScript 对象的构造函数创建</span>。</p><p style=\"line-height: normal;\"><span style=\"font-size: 16px; font-family: 微软雅黑,Microsoft YaHei;\"></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">控制器中既可以有属性，又可以有方法。如下：</span></p><pre class=\"brush:html;toolbar:false\">&lt;div&nbsp;ng-app=&quot;myApp&quot;&nbsp;ng-controller=&quot;personCtrl&quot;&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;名:&nbsp;&lt;input&nbsp;type=&quot;text&quot;&nbsp;ng-model=&quot;firstName&quot;&gt;&lt;br&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;姓:&nbsp;&lt;input&nbsp;type=&quot;text&quot;&nbsp;ng-model=&quot;lastName&quot;&gt;&lt;br&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;br&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;姓名:&nbsp;{{fullName()}}\r\n&lt;/div&gt;\r\n&lt;script&gt;\r\n&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;app&nbsp;=&nbsp;angular.module(&#39;myApp&#39;,&nbsp;[]);\r\n&nbsp;&nbsp;&nbsp;&nbsp;app.controller(&#39;personCtrl&#39;,&nbsp;function($scope)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scope.firstName&nbsp;=&nbsp;&quot;John&quot;;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scope.lastName&nbsp;=&nbsp;&quot;Doe&quot;;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scope.fullName&nbsp;=&nbsp;function()&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$scope.firstName&nbsp;+&nbsp;&quot;&nbsp;&quot;&nbsp;+&nbsp;$scope.lastName;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;});\r\n&lt;/script&gt;</pre><p style=\"line-height: 2em;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; color: rgb(255, 0, 0);\"><strong>AngularJS <strong>Service</strong>（服务）</strong></span></p><p style=\"line-height: normal;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在 AngularJS 中，服务是一个函数或对象，可在你的 AngularJS 应用中使用。AngularJS 内建了30 多个服务。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>1、$http 服务</strong></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">$http&nbsp;是 AngularJS 应用中<strong>最常用的服务</strong>。服务向服务器发送请求，应用响应服务器传送过来的数据。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">使用 $http 服务的 <strong>$http.get(url) </strong><strong>或</strong> <strong>$http.post(url,data) </strong>方法向服务器请求数据，类似于Jquery的ajax，如下：</span></p><pre class=\"brush:js;toolbar:false\">var&nbsp;app&nbsp;=&nbsp;angular.module(&#39;myApp&#39;,&nbsp;[]);\r\napp.controller(&#39;myCtrl&#39;,&nbsp;function($scope,&nbsp;$http)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;$http.get(&quot;welcome.htm&quot;)\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(function&nbsp;(response)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scope.myWelcome&nbsp;=&nbsp;response.data;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});\r\n});</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">从上面代码可以看出 $http.get()方法支持链式调用。</span><br/></p><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">2、$location 服务</span></strong><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><br/></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">$location 服务可以使用 DOM 中存在的对象，类似 window.location 对象，但 window.location 对象在 AngularJS 应用中有一定的局限性。</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">AngularJS 会一直监控应用，处理事件变化， AngularJS 使用 <strong>$location</strong> 服务比使用 <strong>window.location</strong> 对象更好。</span></p><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">常用内置方法</span></strong></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">1、<strong>$location.url()</strong>：①不带参数时，表示获取当前页面的URL；②带参数时，表示更改当前URL为指定的URL。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">2、<strong>$location.search()</strong>：不带参数，返回URL中参数部分的JSON对象表示，如下URL中获取参数值：www.aa.com?#user=123<br/></span></p><pre class=\"brush:plain;toolbar:false\">userName&nbsp;=&nbsp;$location.search().user</pre>',0,'angularJS 前端','AngularJS 简介AngularJS 是一个 JavaScript 框架。它可通过 <script> 标签添加到 HTML 页面。它通过 指令 扩展了 HTML，且通过 表达式 绑定数据到 HTML。AngularJS 表达式语法：{{ expression }}。AngularJS 表达式把数据绑定到 HTML，这与 ng-bind 指令有异曲同工之妙。AngularJS 将在表达式书写的...',21,39,'20161220/1482165668191.jpg'),(127,'TCP中的几个状态（SYN, FIN, ACK, PSH, RST, URG）','2016-12-21 13:38:10','<p><span style=\"font-size: 16px;\"><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei;\">TCP(Transmission Control Protocol)传输控制协议</span></strong></span><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><br/><br/>TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。<br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG. \r\n其中，对于我们日常的分析有用的就是前面的五个字段。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(255, 0, 0);\">SYN表示建立连接， FIN表示关闭连接， ACK表示响应， PSH表示有 \r\nDATA数据传输， RST表示连接重置</span>。<strong><br/></strong></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"><strong>位码即TCP的标志位</strong>，有以下6种标示：</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">1、SYN(synchronous建立联机) <br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">2、ACK(acknowledgement 确认) <br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">3、PSH(push传送) <br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">4、FIN(finish结束) <br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">5、RST(reset重置) <br/></span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">6、URG(urgent紧急)</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">Sequence number(顺序号码) \r\nAcknowledge number(确认号码)<br/></span></p><p><strong><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\"></span></strong></p><p style=\"margin-top:10px;margin-right:0;margin-bottom:10px;margin-left: 0;background:white\"><strong><span style=\"font-size:14px;color:#444444\">在</span><span style=\"font-size:14px;font-family:&#39;Tahoma&#39;,&#39;sans-serif&#39;;color:#444444\">TCP/IP</span><span style=\"font-size:14px;color:#444444\">协议中，</span><span style=\"font-size:14px;font-family:&#39;Tahoma&#39;,&#39;sans-serif&#39;;color:#444444\">TCP</span><span style=\"font-size:14px;color:#444444\">协议通过三次握手建立一个可靠的连接</span></strong></p><p style=\"margin-top:10px;margin-right:0;margin-bottom:10px;margin-left: 0;background:white\"><img src=\"/images/20161221/1482301362770034772.png\" title=\"1482301362770034772.png\" alt=\"图片.png\"/><br/></p><p style=\"margin-top:10px;margin-right:0;margin-bottom:10px;margin-left: 0;background:white\"><span style=\"font-size:14px;color:#444444\">第一次握手：客户端尝试连接服务器，向服务器发送</span><span style=\"font-size:14px;font-family:&#39;Tahoma&#39;,&#39;sans-serif&#39;;color:#444444\">syn</span><span style=\"font-size:14px;color:#444444\">包（同步序列编号</span><strong><span style=\"font-size:14px;font-family:&#39;Tahoma&#39;,&#39;sans-serif&#39;;color:#444444\">Synchronize Sequence Numbers</span></strong><span style=\"font-size:14px;color:#444444\">），</span><span style=\"font-size:14px;font-family:&#39;Tahoma&#39;,&#39;sans-serif&#39;;color:#444444\">syn=j</span><span style=\"font-size:14px;color:#444444\">，客户端进入</span><span style=\"font-size:14px;font-family:&#39;Tahoma&#39;,&#39;sans-serif&#39;;color:#444444\">SYN_SEND</span><span style=\"font-size:14px;color:#444444\">状态等待服务器确认；</span></p><p style=\"margin-top:10px;margin-right:0;margin-bottom:10px;margin-left: 0;background:white\"><span style=\"font-size:14px;color:#444444\">第二次握手：服务器接收客户端</span><span style=\"font-size:14px;font-family:&#39;Tahoma&#39;,&#39;sans-serif&#39;;color:#444444\">syn</span><span style=\"font-size:14px;color:#444444\">包并确认（</span><span style=\"font-size:14px;font-family:&#39;Tahoma&#39;,&#39;sans-serif&#39;;color:#444444\">ack=j+1</span><span style=\"font-size:14px;color:#444444\">），同时向客户端发送一个</span><span style=\"font-size:14px;font-family:&#39;Tahoma&#39;,&#39;sans-serif&#39;;color:#444444\">SYN</span><span style=\"font-size:14px;color:#444444\">包（</span><span style=\"font-size:14px;font-family:&#39;Tahoma&#39;,&#39;sans-serif&#39;;color:#444444\">syn=k</span><span style=\"font-size:14px;color:#444444\">），即</span><span style=\"font-size:14px;font-family:&#39;Tahoma&#39;,&#39;sans-serif&#39;;color:#444444\">SYN+ACK</span><span style=\"font-size:14px;color:#444444\">包，此时服务器进入</span><span style=\"font-size:14px;font-family:&#39;Tahoma&#39;,&#39;sans-serif&#39;;color:#444444\">SYN_RECV</span><span style=\"font-size:14px;color:#444444\">状态；</span></p><p style=\"margin-top:10px;margin-right:0;margin-bottom:10px;margin-left: 0;background:white\"><span style=\"font-size:14px;color:#444444\">第三次握手：第三次握手：客户端收到服务器的</span><span style=\"font-size:14px;font-family:&#39;Tahoma&#39;,&#39;sans-serif&#39;;color:#444444\">SYN+ACK</span><span style=\"font-size:14px;color:#444444\">包，向服务器发送确认包</span><span style=\"font-size:14px;font-family:&#39;Tahoma&#39;,&#39;sans-serif&#39;;color:#444444\">ACK(ack=k+1</span><span style=\"font-size:14px;color:#444444\">），此包发送完毕，客户端和服务器进入</span><span style=\"font-size:14px;font-family:&#39;Tahoma&#39;,&#39;sans-serif&#39;;color:#444444\">ESTABLISHED</span><span style=\"font-size:14px;color:#444444\">状态，完成三次握手。</span></p><p style=\"margin-top:10px;margin-right:0;margin-bottom:10px;margin-left: 0;background:white\"><span style=\"font-size:14px;color:#444444\"><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在完成三次握手后，客户端与服务器才开始传送数据。</span></span></p><p style=\"margin-top:10px;margin-right:0;margin-bottom:10px;margin-left: 0;background:white\"><span style=\"font-size:14px;color:#444444\">定睛一看，服务器</span><span style=\"font-size:14px;font-family:&#39;Tahoma&#39;,&#39;sans-serif&#39;;color:#444444\">socket</span><span style=\"font-size:14px;color:#444444\">与客户端</span><span style=\"font-size:14px;font-family:&#39;Tahoma&#39;,&#39;sans-serif&#39;;color:#444444\">socket</span><span style=\"font-size:14px;color:#444444\">建立连接的部分其实就是大名鼎鼎的三次握手：</span></p><p style=\"margin-top:10px;margin-right:0;margin-bottom:10px;margin-left: 0;background:white\"><img src=\"/images/20161221/1482301374457030165.png\" title=\"1482301374457030165.png\" alt=\"图片.png\"/><br/></p><p><br/></p>',0,'TCP 状态 三次握手','TCP(Transmission Control Protocol)传输控制协议TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG. \r\n其中，对于我们日常的分析有用的就是前面的五个字段。SYN表示建立连接， FIN表示关闭连接， ACK表示响应， PS...',38,40,'20161221/1482298690754.jpg'),(128,'为什么在迭代器遍历集合过程中不能添加或修改元素','2016-12-30 13:31:02','<p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">在学习集合的知识时，可能很多人会跟我有一样的疑问，那就是使用迭代器遍历集合的过程中为什么不能添加或修改元素？</span></p><pre class=\"brush:java;toolbar:false\">public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;String&gt;&nbsp;sList&nbsp;=&nbsp;new&nbsp;ArrayList&lt;String&gt;();\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sList.add(&quot;1&quot;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sList.add(&quot;2&quot;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(String&nbsp;str&nbsp;:&nbsp;sList)&nbsp;{\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sList.add(&quot;2&quot;);\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(sList);\r\n&nbsp;&nbsp;&nbsp;&nbsp;}</pre><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">乍一看，上面的代码似乎没有问题。但是我们一运行，就会发现它抛出了一个 java.util.ConcurrentModificationException 异常。这是为什么呢？</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">从逻辑上来讲，当集合迭代时是允许向集合中添加元素的。但是一旦开放这个功能，很有可能造成很多意想不到的情况。<br/>比如在迭代一个 ArrayList 时，迭代器的工作方式是依次返回给你第0个元素，第1个元素，等等，假设当你迭代到第5个元素的时候，你突然在 ArrayList 的头部插入了一个元素，使得你所有的元素都往后移动，于是你当前访问的第5个元素就会被重复访问。<br/>&nbsp;java 认为在迭代过程中，容器应当保持不变。因此，在 java 容器中通常保留了一个域称为 modCount ，每次你对容器修改，这个值就会加1。当你调用 iterator 方法时，返回的迭代器会记住当前的 modCount，随后迭代过程中会检查这个值，一旦发现这个值发生变化，就说明你对容器做了修改，就会抛出异常。</span></p><p><span style=\"font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;\">针对这个问题，有两个解决方案：<br/>1. 新建一个集合，然后将要添加的元素添加到新的集合中，最后通过 addAll 方法将新集合与原来的集合进行合并；<br/>2. 不用 Iterator 迭代器，而是用 for 循环来遍历，但是要注意死循环情况的避免（循环要有出口）。</span><br/></p>',0,'Iterator 基础 集合','在学习集合的知识时，可能很多人会跟我有一样的疑问，那就是使用迭代器遍历集合的过程中为什么不能添加或修改元素？public static void main(String[] args) {                List<String> sList = new ArrayList<String>();        sList.add(\"1\");        sList.add(\"2\")...',24,10,'20161230/1483075862695.jpg');

/*Table structure for table `blog_type` */

DROP TABLE IF EXISTS `blog_type`;

CREATE TABLE `blog_type` (
  `type_id` int(11) NOT NULL AUTO_INCREMENT,
  `type_name` varchar(30) DEFAULT NULL COMMENT '类型名称',
  `order_no` int(11) DEFAULT NULL COMMENT '序号',
  PRIMARY KEY (`type_id`)
) ENGINE=InnoDB AUTO_INCREMENT=42 DEFAULT CHARSET=utf8;

/*Data for the table `blog_type` */

insert  into `blog_type`(`type_id`,`type_name`,`order_no`) values (1,'默认分类',3),(10,'Java基础',2),(11,'Java Web',2),(12,'前端学习',3),(13,'Spring MVC',4),(14,'Spring AOP',5),(15,'Hibernate',3),(16,'数据结构与算法',3),(17,'Struts2',6),(18,'设计模式',2),(23,'数据库',4),(24,'Spring IOC',6),(26,'Java虚拟机',2),(27,'ExtJS',6),(28,'Android',4),(29,'C#.NET',5),(30,'生活随记',3),(32,'Java集合',3),(33,'多线程',2),(34,'DOM解析',3),(35,'JSch',1),(36,'Quartz',1),(38,'Java中的IO',2),(39,'AngularJS',2),(40,'计算机网络',1),(41,'Redis',1);

/*Table structure for table `blogger` */

DROP TABLE IF EXISTS `blogger`;

CREATE TABLE `blogger` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `nick_name` varchar(30) DEFAULT NULL COMMENT '昵称',
  `signature` varchar(50) DEFAULT NULL COMMENT '个性签名',
  `image_url` varchar(50) DEFAULT NULL COMMENT '头像地址',
  `profile` text COMMENT '简介',
  `user_name` varchar(30) DEFAULT NULL COMMENT '登录名',
  `password` varchar(50) DEFAULT NULL COMMENT '密码',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

/*Data for the table `blogger` */

insert  into `blogger`(`id`,`nick_name`,`signature`,`image_url`,`profile`,`user_name`,`password`) values (1,'Promising','不想当老板的程序员不是好老师','20161123/1479869068046.jpg','<p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">网名：Promising</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">性别：男</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">出生日期：xxxx年xx月xx日</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">爱好：编程，羽毛球</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">座右铭：No Pains，No Gains.</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><br/></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>关于博客</strong></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">V1.0 2016年10月14日发布</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong><span style=\"font-family: arial,helvetica,sans-serif; font-size: 16px;\"></span></strong></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">1. 使用Spring4+Springmvc+Mybatis3架构；</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">2. 采用MySQL数据库存储数据；</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">3. 使用Maven管理项目，使用Lucene作为全文和关键词检索；</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">4. 前台网页使用主流的bootstrap 框架，支持响应式布局；</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">5. 数据库连接池使用的是阿里巴巴的Druid，它被称为“为监控而生的数据库连接池”；</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">6. 在线编辑器使用了百度的UEditor，支持单图，多图上传，同时支持代码高亮特性；<span style=\"font-family: arial,helvetica,sans-serif; font-size: 18px;\"><strong><span style=\"font-family: arial,helvetica,sans-serif; font-size: 16px;\"></span></strong></span><br/></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">V2.0 2016年11月23号发布</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">\r\n\r\n	修复一些Bug：<br/>1. 去除摘要中的html标签；</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">2. 修复分页控制问题：当数据条数未达到分页标准时也显示分页；</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\">3. 添加博客分享链接功能；</span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong><br/></strong></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><strong>GitHub地址：<a href=\"https://github.com/xiongjuncheng/MyBlog\" target=\"_blank\" title=\"https://github.com/xiongjuncheng/MyBlog\">https://github.com/xiongjuncheng/MyBlog</a><br/></strong><br/></span></p><p><span style=\"font-size: 14px; font-family: 微软雅黑,Microsoft YaHei;\"><br/></span></p>','admin','123');

/*Table structure for table `comment` */

DROP TABLE IF EXISTS `comment`;

CREATE TABLE `comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `content` text COMMENT '评论内容',
  `comment_date` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '评论时间',
  `is_pass` tinyint(1) DEFAULT '0' COMMENT '是否通过',
  `blog_id` int(11) DEFAULT NULL COMMENT '博客',
  `user_name` varchar(30) DEFAULT NULL COMMENT '用户',
  `reply` text COMMENT '作者回复',
  `parent_id` int(11) DEFAULT NULL COMMENT '父级评论id',
  `reply_date` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '评论回复时间',
  PRIMARY KEY (`id`),
  KEY `blog_id` (`blog_id`),
  KEY `parent_id` (`parent_id`),
  CONSTRAINT `comment_ibfk_1` FOREIGN KEY (`blog_id`) REFERENCES `blog` (`id`),
  CONSTRAINT `comment_ibfk_2` FOREIGN KEY (`parent_id`) REFERENCES `comment` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=39 DEFAULT CHARSET=utf8;

/*Data for the table `comment` */

insert  into `comment`(`id`,`content`,`comment_date`,`is_pass`,`blog_id`,`user_name`,`reply`,`parent_id`,`reply_date`) values (34,'好啊','2016-11-23 22:50:10',1,89,'asd','呵呵',NULL,'2016-11-23 22:50:10'),(35,'学习了。','2016-11-25 16:24:17',1,98,'一只程序猿','谢谢支持！',NULL,'2017-01-02 18:00:03'),(36,'谢谢大神的总结！','2016-11-25 16:26:12',1,98,'程序猿2号','呵呵，大神不敢当~',NULL,'2017-01-02 17:58:57'),(37,'博主总结得太好了！已收藏','2016-12-09 13:48:35',1,116,'coder_1','呵呵，谢谢支持~',NULL,'2016-12-09 13:48:35'),(38,'不错','2017-01-02 14:34:06',1,98,'攻城狮','谢谢支持~',NULL,'2017-01-02 14:39:06');

/*Table structure for table `link` */

DROP TABLE IF EXISTS `link`;

CREATE TABLE `link` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `link_name` varchar(50) DEFAULT NULL COMMENT '链接名称',
  `link_url` varchar(100) DEFAULT NULL COMMENT '链接地址',
  `order_no` int(11) DEFAULT NULL COMMENT '序号',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;

/*Data for the table `link` */

insert  into `link`(`id`,`link_name`,`link_url`,`order_no`) values (4,'开源中国在线工具','tool.oschina.net',1),(5,'ImportNew','www.importnew.com/',2),(6,'牛客网','www.nowcoder.com',1),(7,'Github','www.github.com',2),(8,'实验楼','www.shiyanlou.com',4);

/*Table structure for table `user` */

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_name` varchar(30) DEFAULT NULL COMMENT '用户名',
  `password` varchar(50) DEFAULT NULL COMMENT '密码',
  `email` varchar(50) DEFAULT NULL COMMENT '邮箱',
  `website` varchar(100) DEFAULT NULL COMMENT '网站',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=37 DEFAULT CHARSET=utf8;

/*Data for the table `user` */

insert  into `user`(`id`,`user_name`,`password`,`email`,`website`) values (28,'admin',NULL,'1453697409@qq.com','www.juncheng1994.cn'),(29,'各个',NULL,'',''),(30,'各个',NULL,'',''),(31,'码农',NULL,'1453697409@qq.com','www.juncheng1994.cn'),(32,'asd',NULL,'',''),(33,'一只程序猿',NULL,'','www.baidu.com'),(34,'程序猿2号',NULL,'',''),(35,'coder_1',NULL,'123132@eqw','www.juncheng1994.cn'),(36,'攻城狮',NULL,'','');

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
